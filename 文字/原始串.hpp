#pragma once
#include"基本定义/属性范式.hpp"
#include"小工具/局部函数.hpp"
#include"文字/万国码.hpp"
#define  _                 (__原始串) u""

定义 局部函数<文字 * (自然数)> 分配回调;

内联链接 自然数 宽度(文字 值) {
    回递 值 <= 0xff ? 1 : 2;
}

结构体 字符串;

命名空间 原始串空间{
    三体(类 类型);
    模板<类 类型> 结构体 数据{
        卡诺匹斯(类型);
        自然数   长度;
        文字   * 指针;
        符号常量 数据(文字 常量 * 串) {
            指针 = (文字 *)串;
            只要(串[0]) {
                串++;
            }
            长度 = 串 - 指针;
        }
        数据() : 指针(u""), 长度(0) {}
        数据(文字 常量 * 指针, 自然数 个数) :
            长度(个数), 指针((文字 *)指针) {
        }
    };
    
    模板<类 原始串> 结构体 接口{
        卡诺匹斯(原始串);
        原始串 左填充(自然数 填充长度, 分配回调 回调) {
            回递 左填充(填充长度, ' ', 回调);
        }
        原始串 左填充(自然数 填充长度, 文字 填充符, 分配回调 回调){
            文字 * 缓冲区 = 回调(填充长度 + 长度);
            填充<文字>(缓冲区, 填充符, 填充长度);
            复制<文字>(缓冲区 + 填充长度, 指针, 长度);
            回递 原始串(缓冲区, 填充长度 + 长度);
        }
        原始串 右填充(自然数 填充长度, 分配回调 回调) {
            回递 右填充(填充长度, ' ', 回调);
        }
        原始串 右填充(自然数 填充长度, 文字 填充符, 分配回调 回调){
            文字 * 缓冲区 = 回调(填充长度 + 长度);
            复制<文字>(缓冲区, 指针, 长度);
            填充<文字>(缓冲区 + 长度, 填充符, 填充长度);
            回递 原始串(缓冲区, 填充长度 + 长度);
        }
        
        原始串 两端填充(自然数 左填充长度, 自然数 右填充长度, 分配回调 回调) {
            回递 两端填充(左填充长度, 右填充长度, ' ', 回调);
        }
        原始串 两端填充(自然数 左填充长度, 自然数 右填充长度, 文字 填充符, 分配回调 回调){
            自然数 总长 = 左填充长度 + 右填充长度 + 长度;
            文字 * 缓冲区 = 回调(总长);
            填充<文字>(缓冲区, 填充符, 左填充长度);
            复制<文字>(缓冲区 + 左填充长度, 指针, 长度);
            填充<文字>(缓冲区 + 左填充长度 + 长度, 填充符, 右填充长度);
            回递 原始串(缓冲区, 总长);
        }

        #define $F1                                                   \
            自然数 本串宽度 = $I.总宽;                                \
            自然数 填充宽度;                                          \
            自然数 填充长度;                                          \
            自然数 左填充长度 = 0;                                    \
            自然数 右填充长度 = 0;                                    \
            自然数 总长;                                              \
            原始串 结果;                                              \
            布尔   存在半字;                                          \
            文字 * 缓冲区;                                            \
                                                                      \
            若 (本串宽度 >= 总宽){                                    \
                缓冲区 = 回调(长度);                                  \
                总长 = 长度;                                          \
                复制<文字>(缓冲区, 指针, 长度);                       \
                结果 = 原始串(缓冲区, 总长);                          \
            }                                                         \
            非{                                                       \
                填充宽度 = 总宽 - 本串宽度;                           \
                存在半字 = 填充宽度 % ::宽度(填充符);                 \
                填充长度 = 填充宽度 / ::宽度(填充符) + 存在半字;

        #define $F2(填充,半字位置)                                    \
            $F1 结果 = 填充(填充长度, 填充符, 回调);                  \
                                                                      \
                若 (存在半字){                                        \
                    结果[半字位置] = ' ';                             \
                }                                                     \
            $                                                         \
            回递 结果;

        原始串 左对齐(自然数 总宽, 文字 填充符, 分配回调 回调) {
            $F2(右填充, 长度);
        }

        原始串 右对齐(自然数 总宽, 文字 填充符, 分配回调 回调) {
            $F2(左填充, 填充长度 - 1);
        }

        原始串 居中对齐(自然数 总宽, 文字 填充符, 分配回调 回调){
            $F1 左填充长度 = 填充长度 / 2;
                右填充长度 = 填充长度 - 左填充长度;
                结果 = 两端填充(左填充长度, 右填充长度, 填充符, 回调);

                若 (存在半字){
                    结果[左填充长度 + 长度] = ' ';
                }
            $
            回递 结果;
        }

        #undef $F1
        #undef $F2

        模板<类 格式化回调> 
        原始串 元素变换(格式化回调 格式化, 分配回调 分配) {
            文字 * 缓冲区 = 分配(长度);
            循环(自然数 下标 = 0; 下标 < 长度; 下标++) {
                缓冲区[下标] = 格式化(指针[下标]);
            }
            回递 原始串(缓冲区, 长度);
        }

        模板<类 比较回调, 类 匹配回调>
        自然数 正向匹配(原始串 子串, 匹配回调 匹配器, 比较回调 比较){
            自然数   不匹配下标 = 0;
            自然数   匹配下标;
            自然数   下标;
            推导类型 源串 = 原始串(指针, 长度);

            只要((匹配下标 = 匹配器(源串, 子串[不匹配下标])) != 不存在) {
                源串 += 匹配下标 - 不匹配下标;

                若 (源串->长度 < 子串->长度){
                    回递 不存在;
                }

                下标 = 0;

                只要(是) {
                    若 (下标 == 子串->长度){
                        回递 源串->指针 - 指针;
                    }
                    若 (比较(源串[下标], 子串[下标]) != 0) {
                        不匹配下标 = 下标;
                        跳出;
                    }
                    下标++;
                }
            }
            回递 不存在;
        }

        模板<类 匹配回调>
        自然数 正向匹配(匹配回调 回调) {
            循环(自然数 下标 = 0; 下标 < 长度; 下标++){
                若 (回调(指针[下标]) == 0){
                    回递 下标;
                }
            }
            回递 不存在;
        }

        
        模板<类 比较回调, 类 匹配回调>
        自然数 反向匹配(原始串 子串, 匹配回调 匹配器, 比较回调 比较){
            自然数      不匹配下标 = 0;
            自然数      匹配下标;
            自然数      下标;
            推导类型    源串 = 原始串(指针, 长度);
            文字 常量 * 源指针;

            若 (源串->长度 < 子串->长度 || 源串->长度 == 0 || 子串->长度 == 0){
                回递 不存在;
            }

            //[不匹配下标] = 0
            //让[源串]匹配[子串[0]] 那么在第一个匹配的下标 
            //不能超过[源串->长度] - 子串->长度
            //因为子串还有后续元素
            //源串:"123451235"
            //子串:       "34"
            //     |---+---|
            //         |
            //    可匹配的长度
            源串->长度 = 源串->长度 - 子串->长度 + 1;

            只要((匹配下标 = 匹配器(源串, 子串[不匹配下标])) != 不存在) {
                源串->长度 = 匹配下标 - 不匹配下标;
                源指针 = 源串->指针 + 源串->长度;
                源串->长度 = 源串->长度 + 1;
                下标 = 0;

                只要(是){
                    若 (下标 == 子串->长度){
                        回递 源串->长度 - 1;
                    }
                    若 (比较(源指针[下标], 子串[下标]) != 0){
                        不匹配下标 = 下标;
                        跳出;
                    }
                    下标++;
                }
            }
            回递 不存在;
        }
        
        模板<类 匹配回调>
        自然数 反向匹配(匹配回调 回调) {
            循环(自然数 下标 = 长度; 下标-- > 0; ){
                若 (回调(指针[下标]) == 0){
                    回递 下标;
                }
            }
            回递 不存在;
        }

        #define 生成(顺序符)                                                         \
        自然数 顺序符 ## 向匹配(阿斯克码 比对值) {                                   \
            回递 顺序符 ## 向匹配(文字(比对值));                                     \
        }                                                                            \
                                                                                     \
        自然数 顺序符 ## 向匹配(文字 比对值) {                                       \
            回递 顺序符 ## 向匹配([=](文字 值){                                      \
                回递 比较(值, 比对值);                                               \
            });                                                                      \
        }                                                                            \
                                                                                     \
        自然数 顺序符 ## 向匹配(原始串 比对值) {                                     \
            回递 顺序符 ## 向匹配(比对值,                                            \
                [](原始串 源串, 文字 值){                                            \
                    回递 源串->顺序符 ## 向匹配(值);                                 \
                }, 默认比较<文字>()                                                  \
            );                                                                       \
        }                                                                            \
                                                                                     \
        自然数 顺序符 ## 向匹配并忽略大小写(文字 比对值) {                           \
            回递 顺序符 ## 向匹配([=](文字 值) {                                     \
                回递 比较<文字>(万国码(值)->小写格式, 万国码(比对值)->小写格式);     \
            });                                                                      \
        }                                                                            \
                                                                                     \
        自然数 顺序符 ## 向匹配并忽略大小写(原始串 比对值) {                         \
            回递 顺序符 ## 向匹配(比对值,                                            \
                [](原始串 源串, 文字 值){                                            \
                    回递 源串->顺序符 ## 向匹配并忽略大小写(值);                     \
                },                                                                   \
                [](文字 左, 文字 右){                                                \
                    回递 比较<文字>(万国码(左)->小写格式, 万国码(右)->小写格式);     \
                }                                                                    \
            );                                                                       \
        }

        生成(正);
        生成(反);
        #undef 生成

        整数 等长比较(原始串 比对值, 自然数 比较长度, 比较回调<文字> 比较 = 默认比较<文字>()){
            循环(自然数 下标 = 0; 下标 < 比较长度; 下标++) {
                整数 结果 = 比较($O[下标], 比对值[下标]);
                若 (结果 != 0) {
                    回递 结果;
                }
            }
            回递 0;
        }

        整数 字典序比较(原始串 比对值, 比较回调<文字> 比较 = 默认比较<文字>()){
            若 (长度 == 0) {
                回递 比对值->长度 == 0 ? 0 : -1;
            }
            若 (比对值->长度 == 0) {
                回递 1;
            }
 
            自然数 比较长度;
            整数   最后返回;
 
            若 (长度 > 比对值->长度) {
                比较长度 = 比对值->长度;
                最后返回 = 1;
            }
            或 (长度 < 比对值->长度) {
                比较长度 = 长度;
                最后返回 = -1;
            }
            非{
                比较长度 = 长度;
                最后返回 = 0;
            }
        
            整数 比较结果 = 等长比较(比对值, 比较长度, 比较);

            若 (比较结果 == 0){
                回递 最后返回;
            }
            回递 比较结果;
        }
    
        整数 快速比较(原始串 比对值, 比较回调<文字> 比较 = 默认比较<文字>()){
            若 (长度 > 比对值->长度) {
                回递 1;
            }
            若 (长度 < 比对值->长度) {
                回递 -1;
            }
            若 (长度 == 0) {
                回递 0;
            }
            回递 等长比较(比对值, 长度, 比较);
        }

        属性(自然数, 长度)
            公有读 { 回递 $D.长度; }
            公有写 { $D.长度 = 值; }
        $

        属性(文字 *, 指针)
            公有读 { 回递 $D.指针; }
            公有写 { $D.指针 = 值; }
        $

        只读属性(自然数, 总宽){
            自然数 结果 = 0;
            循环(自然数 I = 0; I < $I.长度; I++) {
                结果 += 宽度(指针[I]);
            }
            回递 结果;
        }
    私有
    };
    
    模板<类 类型> 结构体 运算{
        运算型卡诺匹斯(类型);
        运算重载 文字 *(){
            回递 $D.指针;
        }
        整数 运算重载 - (运算 常量 & 值) {
            回递 $D.指针 - ((运算 &)值)->指针;
        }
        类型 运算重载-- (I32) {
            类型 临时 = $D;
            此 -= 1;
            回递 临时;
        }
        类型 运算重载++ (I32) {
            类型 临时 = $D;
            此 += 1;
            回递 临时;
        }
        类型 运算重载-- () {
            此 -= 1;
            回递 此;
        }
        运算类型 运算重载++ () {
            此 += 1;
            回递 此;
        }
        类型 运算重载 - (自然数 偏移) {
            类型 临时 = $D;
            临时 -= 偏移;
            回递 临时;
        }
        类型 运算重载 + (自然数 偏移) {
            类型 临时 = $D;
            临时 += 偏移;
            回递 临时;
        }
        空 运算重载 -= (自然数 偏移) {
            $I.长度 = $I.长度 + 偏移;
            $I.指针 = $I.指针 - 偏移;
        }
        空 运算重载 += (自然数 偏移) {
            $I.长度 = $I.长度 - 偏移;
            $I.指针 = $I.指针 + 偏移;
        }
    };
}

结构体 原始串;
结构体 原始串 : 原始串空间::运算<原始串>{
    符号常量 原始串(文字 常量 * 串):
        数据(串) {
    }
    原始串(){}
    原始串(字符串 &&) = 删;
    原始串(原始串 串, 自然数 长度) :
        数据(串->指针, 长度){
    }
    原始串(原始串空间::数据<原始串> 数据) :
        数据(数据){
    }
    原始串(文字 常量 * 串, 自然数 个数) :
        数据(串, 个数){
    }
    空 运算重载=(字符串 &&) = 删;
私有
    数据类型 数据;
};

定义 原始串 __原始串;