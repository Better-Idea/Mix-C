#pragma once
#include"基本定义/属性范式.hpp"
#include"小工具/局部函数.hpp"
#define  _                 (原始串) u""

定义 局部函数<文字 * (自然数)> 分配回调;

内联链接 自然数 宽度(文字 值) {
    回递 值 <= 0xff ? 1 : 2;
}

结构体 字符串;

命名空间 原始串空间{
    三体(类 类型);
    模板<类 类型> 结构体 数据{
        卡诺匹斯(类型);
        自然数   长度;
        文字   * 指针;
        符号常量 数据(文字 常量 * 串) {
            指针 = (文字 *)串;
            只要(串[0]) {
                串++;
            }
            长度 = 串 - 指针;
        }
        数据() : 指针(u""), 长度(0) {}
        数据(文字 常量 * 指针, 自然数 个数) :
            长度(个数), 指针((文字 *)指针) {
        }
    };
    
    模板<类 原始串> 结构体 接口{
        卡诺匹斯(原始串);
        原始串 左填充(自然数 填充长度, 分配回调 回调) {
            回递 左填充(填充长度, ' ', 回调);
        }
        原始串 左填充(自然数 填充长度, 文字 填充符, 分配回调 回调){
            文字 * 缓冲区 = 回调(填充长度 + 长度);
            填充<文字>(缓冲区, 填充符, 填充长度);
            复制<文字>(缓冲区 + 填充长度, 指针, 长度);
            回递 原始串(缓冲区, 填充长度 + 长度);
        }
        原始串 右填充(自然数 填充长度, 分配回调 回调) {
            回递 右填充(填充长度, ' ', 回调);
        }
        原始串 右填充(自然数 填充长度, 文字 填充符, 分配回调 回调){
            文字 * 缓冲区 = 回调(填充长度 + 长度);
            复制<文字>(缓冲区, 指针, 长度);
            填充<文字>(缓冲区 + 长度, 填充符, 填充长度);
            回递 原始串(缓冲区, 填充长度 + 长度);
        }
        
        原始串 两端填充(自然数 左填充长度, 自然数 右填充长度, 分配回调 回调) {
            回递 两端填充(左填充长度, 右填充长度, ' ', 回调);
        }
        原始串 两端填充(自然数 左填充长度, 自然数 右填充长度, 文字 填充符, 分配回调 回调){
            自然数 总长 = 左填充长度 + 右填充长度 + 长度;
            文字 * 缓冲区 = 回调(总长);
            填充<文字>(缓冲区, 填充符, 左填充长度);
            复制<文字>(缓冲区 + 左填充长度, 指针, 长度);
            填充<文字>(缓冲区 + 左填充长度 + 长度, 填充符, 右填充长度);
            回递 原始串(缓冲区, 总长);
        }

        #define $F1                                                   \
            自然数 本串宽度 = $I.总宽;                                \
            自然数 填充宽度;                                          \
            自然数 填充长度;                                          \
            自然数 左填充长度 = 0;                                    \
            自然数 右填充长度 = 0;                                    \
            自然数 总长;                                              \
            原始串 结果;                                              \
            布尔   存在半字;                                          \
            文字 * 缓冲区;                                            \
                                                                      \
            若 (本串宽度 >= 总宽){                                    \
                缓冲区 = 回调(长度);                                  \
                总长 = 长度;                                          \
                复制<文字>(缓冲区, 指针, 长度);                       \
                结果 = 原始串(缓冲区, 总长);                          \
            }                                                         \
            非{                                                       \
                填充宽度 = 总宽 - 本串宽度;                           \
                存在半字 = 填充宽度 % ::宽度(填充符);                 \
                填充长度 = 填充宽度 / ::宽度(填充符) + 存在半字;

        #define $F2(填充,半字位置)                                    \
            $F1 结果 = 填充(填充长度, 填充符, 回调);                  \
                                                                      \
                若 (存在半字){                                        \
                    结果[半字位置] = ' ';                             \
                }                                                     \
            $                                                         \
            回递 结果;

        原始串 左对齐(自然数 总宽, 文字 填充符, 分配回调 回调) {
            $F2(右填充, 长度);
        }

        原始串 右对齐(自然数 总宽, 文字 填充符, 分配回调 回调) {
            $F2(左填充, 填充长度 - 1);
        }

        原始串 居中对齐(自然数 总宽, 文字 填充符, 分配回调 回调){
            $F1 左填充长度 = 填充长度 / 2;
                右填充长度 = 填充长度 - 左填充长度;
                结果 = 两端填充(左填充长度, 右填充长度, 填充符, 回调);

                若 (存在半字){
                    结果[左填充长度 + 长度] = ' ';
                }
            $
            回递 结果;
        }

        #undef $F1
        #undef $F2

        属性(自然数, 长度)
            公有读 { 回递 $D.长度; }
            公有写 { $D.长度 = 值; }
        $

        属性(文字 常量 *, 指针)
            公有读 { 回递 $D.指针; }
            公有写 { $D.指针 = 值; }
        $

        只读属性(自然数, 总宽){
            自然数 结果 = 0;
            循环(自然数 I = 0; I < $I.长度; I++) {
                结果 += 宽度(指针[I]);
            }
            回递 结果;
        }
    私有
    };
    
    模板<类 类型> 结构体 运算{
        运算型卡诺匹斯(类型);
        运算重载 文字 *(){
            回递 $D.指针;
        }
        整数 运算重载 - (运算 常量 & 值) {
            回递 $D.指针 - ((运算 &)值)->指针;
        }
        类型 运算重载-- (I32) {
            类型 临时 = $D;
            此 -= 1;
            回递 临时;
        }
        类型 运算重载++ (I32) {
            类型 临时 = $D;
            此 += 1;
            回递 临时;
        }
        类型 运算重载-- () {
            此 -= 1;
            回递 此;
        }
        运算类型 运算重载++ () {
            此 += 1;
            回递 此;
        }
        类型 运算重载 - (自然数 偏移) {
            类型 临时 = $D;
            临时 -= 偏移;
            回递 临时;
        }
        类型 运算重载 + (自然数 偏移) {
            类型 临时 = $D;
            临时 += 偏移;
            回递 临时;
        }
        空 运算重载 -= (自然数 偏移) {
            $I.长度 = $I.长度 + 偏移;
            $I.指针 = $I.指针 - 偏移;
        }
        空 运算重载 += (自然数 偏移) {
            $I.长度 = $I.长度 - 偏移;
            $I.指针 = $I.指针 + 偏移;
        }
    };
}

结构体 原始串;
结构体 原始串 : 原始串空间::运算<原始串>{
    符号常量 原始串(文字 常量 * 串):
        数据(串) {
    }
    原始串(){}
    原始串(字符串 &&) = 删;
    原始串(原始串 串, 自然数 长度) :
        数据(串->指针, 长度){
    }
    原始串(原始串空间::数据<原始串> 数据) :
        数据(数据){
    }
    原始串(文字 常量 * 串, 自然数 个数) :
        数据(串, 个数){
    }
    空 运算重载=(字符串 &&) = 删;
私有
    数据类型 数据;
};

模板<类 格式化回调> 
内联链接 空 格式化管道(原始串 源头, 格式化回调 格式化, 分配回调 分配) {
    文字 * 缓冲区 = 分配(源头->长度);
    循环(自然数 下标 = 0; 下标 < 源头->长度; 下标++) {
        缓冲区[下标] = 格式化(源头->指针[下标]);
    }
}

#undef $EM
