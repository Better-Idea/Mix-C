#pragma once
#include"基本定义/迷你.hpp"
#include"基本定义/属性范式.hpp"
#include"指令集/基础.hpp"

命名空间 位绑定空间{
    三体(类 甲, 类 二值 = 布尔);
    模板<类 甲, 类 二值> 结构体 数据{
        卡诺匹斯(甲, 二值);
        甲  *    指针;
        自然数   下标;
        数据() {
            指针 = 空值;
        }
        数据(甲 & 值, 自然数 下标):
            指针(& 值), 下标(下标){
        }
    };

    模板<类 甲, 类 二值> 结构体 接口{
        卡诺匹斯(甲, 二值);
        空 置位() {
            指令集::位测试后位置位($D.指针[0], $D.下标);
        }
        空 复位() {
            指令集::位测试后位复位($D.指针[0], $D.下标);
        }
        空 取反() {
            指令集::位测试后位取反($D.指针[0], $D.下标);
        }
        布尔 位测试后位置位() {
            回递 指令集::位测试后位置位($D.指针[0], $D.下标);
        }
        布尔 位测试后位复位() {
            回递 指令集::位测试后位复位($D.指针[0], $D.下标);
        }
        布尔 位测试后位取反() {
            回递 指令集::位测试后位取反($D.指针[0], $D.下标);
        }
    };

    模板<类 甲, 类 二值>
    结构体 运算{
        运算型卡诺匹斯(甲, 二值);

        模板<类 数值类型>
        推导类型 & 运算重载 = (数值类型 常量 & 值) {
            (布尔)(自然数)(数值类型 &)值 ? $I.置位() : $I.复位();
            回递 此;
        }

        布尔 运算重载 !() 常量 {
            回递 !运算重载 布尔();
        }

        运算重载 布尔() 常量 {
            回递 指令集::位测试($D.指针[0], $D.下标);
        }

        运算重载 二值() 常量 {
            回递 (二值)运算重载 布尔();
        }
    };
}

模板<类 类型, 类 二值 = 布尔> 
结构体 绑定位 : 位绑定空间::运算<类型, 二值>{
    绑定位(){}
    绑定位(类型 & 值, 自然数 下标) : 
        数据(值, 下标){
    }

    模板<类 数值类型>
    推导类型 & 运算重载 = (数值类型 常量 & 值) {
        回递 位绑定空间::运算<类型, 二值>::运算重载 = (值);
    }
私有
    位绑定空间::数据<类型, 二值> 数据;
};

