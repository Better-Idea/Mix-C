# 属性范式
## 有啥用？
说实话它就让你在访问属性的时候少写一个括号，哈哈

## 头脑风暴
绝后型
```
#define $ (*(the_owner *)this)
union name{
private:
    typedef name the_owner;
    struct data{
        U32 A;
    }meta;

    data * operator->(){
        return & meta;
    }
public:
    struct {
        operator U32 (){
            return $->A;
        }
    private:
        friend the_owner;
        void operator= (U32 value){
            $->A = value;
        }
    }A;
};
```

膨胀型
```
//你猜
```

混合型
```
//你再猜
```

## 设计初衷
- VC++平台一个关键就能解决的问题，但不能跨平台有啥用？
- 代码君前后废弃三种实现方式，绞尽脑汁实现了这个有点蹩脚的属性特性，希望在精心设计的代码库中可以使用这个特性

## 用法
### 第一步:包含这两个头文件
```
#pragma once
#include"基本定义/迷你.hpp"  
#include"基本定义/属性范式.hpp"
```

### 第二步:创建命名空间,命名规则如下
```
命名空间 XXX空间{
```

### 第三步:在 XXX空间 下添加 三体 这个前置声明
添加**三体**这个宏函数用于前置声明接下来的结构体  
**三体**里面填写的参数和模块模板的参数格式一致,如果模块不是模板,那么则用**哑元**命名:
```
    // 三体(类 元素);
    三体(类 哑元);
```

### 第四步:创建三体

这里的**三体**代表的是一个结构体拥有的三种特性,即:  
**数据** : 模块的所有字段  
**接口** : 模块的所有属性和函数  
**运算** : 模块的所有运算重载  

```
    模板<类 哑元> 结构体 数据{
        卡诺匹斯(哑元);
    };
    
    模板<类 哑元> 结构体 接口{
        卡诺匹斯(哑元);
    };
    
    模板<类 哑元> 结构体 运算{
        运算型卡诺匹斯(哑元);
    };
```

三体中**运算**结构体中嵌入的则是**运算型卡诺匹斯**  
你可能会好奇**卡诺匹斯**是个什么鬼?  

**关于用卡诺匹斯命名该宏函数的解释:**  
和其他命名撞衫的概率很小  
有容器的含义  
作者世界观里的鬼神学  

**关于卡诺匹斯作用的解释:**  
将三个分立的特性间接联系起来  
三体都来自同一地址空间, 且 **数据** **接口** **运算** 相互强制转换而不会丢失完整性  
为接口中的属性提供正确指向  

### 第五步:完善三体
为**数据**添加字段并初始化它们  
为**接口**添加属性和函数  
为**运算**添加必要的运算重载,如非必要保持原样即可  

**$D**表示将当前结构转化为**数据**结构, **$I**表示将当前结构转化为**接口**结构, **$O**表示将当前结构转化为**运算**结构  

```
    模板<类 哑元> 结构体 数据{
        卡诺匹斯(哑元);
        数据(){
            已用个数 = 0;
        }
        静态 符号常量 自然数 总长 = 100;
        字节                序列[总长];
        自然数              已用个数;
    };
    
    模板<类 哑元> 结构体 接口{
        卡诺匹斯(哑元);

        空 放入(字节 值){
            $D.序列[已用个数] = 值;
            已用个数 = 已用个数 + 1;
        }

        字节 取出(){
            已用个数 = 已用个数 - 1;
            回递 $D.序列[已用个数];
        }

        公有属性(自然数, 已用个数)
            公有读 { 回递 $D.已用个数; } // 类似 C# 的属性
            私有写 { $D.已用个数 = 值; } // 对外只读 对内可读可写
        $

        公有只读(布尔, 已空) 
            回递 $D.已用个数 == 0;
        $

        公有只读(布尔, 已满)
            回递 $D.已用个数 == $D.总长;
        $
    };
    
    模板<类 哑元> 结构体 运算{
        运算型卡诺匹斯(哑元);
    };
```

### 第六步:将三体融入XXX外壳

**为什么XXX叫做外壳?**  
因为XXX是一个装着三体的壳子,本身没有任何特性  
而XXX也是直接对外的,我们通常不直接访问XXX空间中的结构体  

```
}

结构体 XXX;
结构体 XXX : XXX空间::运算<XXX>{
私有
    XXX空间::数据<XXX> 数据;
};
```

### 完整代码
**XXX.hpp文件**
```
#pragma once
#include"基本定义/迷你.hpp"  
#include"基本定义/属性范式.hpp"

命名空间 XXX空间{
    // 三体(类 元素);
    三体(类 哑元);

    模板<类 哑元> 结构体 数据{
        卡诺匹斯(哑元);
        数据(){
            已用个数 = 0;
        }
        静态 符号常量 自然数 总长 = 100;
        字节                序列[总长];
        自然数              已用个数;
    };
    
    模板<类 哑元> 结构体 接口{
        卡诺匹斯(哑元);

        空 放入(字节 值){
            $D.序列[已用个数] = 值;
            已用个数 = 已用个数 + 1;
        }

        字节 取出(){
            已用个数 = 已用个数 - 1;
            回递 $D.序列[已用个数];
        }

        公有属性(自然数, 已用个数)
            公有读 { 回递 $D.已用个数; }
            私有写 { $D.已用个数 = 值; } // 对外只读 对内可读可写
        $

        公有只读(布尔, 已空) 
            回递 $D.已用个数 == 0;
        $

        公有只读(布尔, 已满)
            回递 $D.已用个数 == $D.总长;
        $
    };
    
    模板<类 哑元> 结构体 运算{
        运算型卡诺匹斯(哑元);
    };
}

结构体 XXX;
结构体 XXX : XXX空间::运算<XXX>{
私有
    XXX空间::数据<XXX> 数据;
};
```

**主函数.hpp文件**
```
#include"基本定义/迷你.hpp"
#include"XXX.hpp"

主函数(){
    XXX 某某;

    只要(某某->已满 == 否){
        某某->放入(字节());
    }

    只要(某某->已空 == 否){
        字节 值 = 某某->取出();
    }
    回递 0;
}
```

**更多说明:**  
代码中**某某**的指向运算符来自**XXX**继承的**运算**, 它指向的是**接口**这个结构体  
三体中的**数据**是实心的. 它里面的字段数据是**XXX**模块必须的, 而**数据**占用的字节数则是**XXX**模块真正的大小  
三体中的**接口**是假实心的. 它里面的属性其实也是一个个的字段, 不过在给这些属性赋值的时候, 值并不写到**接口**的这些字段中, 而是通过`$D.XXX = 值;`写到**数据**结构体对应的字段中, 读取属性时也是通过`回递 $D.XXX;`从**数据**结构中获取值.  
三体中的**运算**是空心的, 因为**运算**里面没有任何字段而且总是被**XXX**继承, 所以它俩的内存地址是一样的, 而**XXX**里面也只有**数据**一个成员, 所以以**运算**和**数据**的地址也是一样的, **接口**的地址来自**运算**, 结论就是**三体**在同一地址空间下  
