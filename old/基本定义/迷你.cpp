#pragma warning(disable:28182)
#pragma warning(disable:26495)
#pragma warning(disable:26444)
#pragma warning(disable:6011)
#pragma warning(disable:6031)
#include"指令集/基础.hpp"
#include<malloc.h>

#ifdef _MSC_VER
void * operator new (size_t Bytes, void * Ptr) noexcept {
    return Ptr;
}
#else
void * operator new (unsigned long Bytes, void * Ptr) noexcept {
    return Ptr;
}
#endif

自然数 错误次数;
自然数 错误阈值 = 32;

命名空间{
    非寄 空 * Null = 空值;
    非寄 空 ** 非寄空值 = &Null;
    自然数 分配指示器;
    自然数 分配字节数;
    自然数 实际字节数;
}

//一些编译器不允许nullptr引用 所以设置成非寄存初始化
空指针 空引用结构::值 = (空指针)非寄空值[0];

自然数 已分配字节数(){
    回递 分配字节数;
}
自然数 分配平衡指示器(){
    回递 分配指示器;
}
自然数 实际分配字节数(){
    回递 实际字节数;
}

#ifdef _MSC_VER
#define 对齐分配 _aligned_malloc
#define 对齐回收 _aligned_free
#else
#define 对齐分配 memalign
#define 对齐回收 free
#endif

#ifdef 三十二位系统
结构体 链{
    链 * 前驱;
    链 * 后继;
私有
    U32  保留[2];
};
#else
结构体 链{
    链 * 前驱;
    链 * 后继;
};
#endif

符号常量 自然数 位移得到块下标     = 4;
符号常量 自然数 位移块对齐         = 位移得到块下标;
符号常量 自然数 单位分配字节       = 1 << 位移得到块下标;
符号常量 自然数 页空间量           = 1024;
符号常量 自然数 位与得到页地址     = ~(页空间量 - 1);
符号常量 自然数 大页个数           = 64;
符号常量 自然数 大页空间量         = 页空间量 * 大页个数;
符号常量 自然数 位与测试线性页已空 = 大页空间量 - 1;
符号常量 自然数 位与得到线性页首页 = ~位与测试线性页已空;

结构体 页;
结构体 空闲页;
结构体 页首部{
    空闲页 * 回收中心;
    U64      指示器;
};

结构体 页 : 页首部{
    静态 符号常量 自然数 管理开销 = 空间量(页首部);
    静态 符号常量 自然数 可分配字节数 = 页空间量 - 管理开销;
    静态 符号常量 自然数 块数 = 可分配字节数 / 单位分配字节;
    链 块组[块数];

    页() {
        指示器 = 0;
        回收中心 = 空值;
    }
    布尔 是空闲态(自然数 下标){
        回递 指令集::位测试(指示器, 下标) == 复位态;
    }
    自然数 左邻空块长度(自然数 下标){
        自然数 掩码 = (自然数(1) << 下标) - 1;
        自然数 左邻 = 指示器 & 掩码;
        
        若 (左邻 == 0){
            回递 下标;
        }

        回递 下标 - 指令集::高位零个数(左邻) - 1;
    }
    自然数 右邻空块长度(自然数 右邻下标){
        自然数 掩码 = ~((自然数(1) << 右邻下标) - 1);
        自然数 右邻 = 指示器 & 掩码;
        
        若 (右邻 == 0){
            回递 块数 - 右邻下标;
        }

        回递 指令集::低位零个数(右邻) - 右邻下标;
    }
    空 标记空闲(自然数 下标){
        指令集::位测试后位复位(& 指示器, 下标);
    }
    空 标记占用(自然数 下标){
        指令集::位测试后位置位(& 指示器, 下标);
    }
};

结构体 空闲页 : 页首部{
    空闲页 * 前驱;
    空闲页 * 后继;
    页     * 首页;
    空 放入(自然数 下标) {
        指令集::位测试后位置位(& 指示器, 下标);
    }
    页 * 取出() {
        自然数 下标 = 指令集::最低置位位索引(指示器);
        指令集::位测试后位复位(& 指示器, 下标);
        回递 首页 + 下标;
    }
    布尔 已空() {
        回递 指示器 == 0;
    }
    布尔 已满() {
        回递 指令集::置位位个数(指示器) == 大页个数 - 1;
    }
    空闲页 * 移除() {
        前驱->后继 = 后继;
        后继->前驱 = 前驱;
        回递 后继 == 此指针 ? 空值 : 后继;
    }
};

结构体 分配器{
    分配器() : 
        页栈(空值), 指示(0){
    }
    
    空指针 分配(自然数 字节数){
        自然数 块对齐分配字节数 = 对齐取整(字节数, 单位分配字节);
        自然数 块数 = 块对齐分配字节数 >> 位移块对齐;

        若 (块对齐分配字节数 >= 页::可分配字节数){
            实际字节数 += 块对齐分配字节数;
            回递 malloc(块对齐分配字节数);
        }

        U64  掩码 = ~((1ull << 块数) - 1);
        U64  匹配项 = 指示 & 掩码;
        自然数 剩余块数 = 0;
        自然数 左边界;
        自然数 右边界;
        自然数 最佳匹配块数;
        页 * 页地址;
        链 * 剩余块地址;
        链 * 可用块地址;
        
        若 (匹配项 == 0){
            页地址 = 页分配();
            再初始化(页, 页地址[0]);
            剩余块数 = 页::块数 - 块数;
            剩余块地址 = 页地址->块组 + 块数;
            右边界 = 块数 - 1;
            页地址->标记占用(右边界);
            添加(剩余块地址, 剩余块数);
            回递 页地址->块组;
        }
        
        最佳匹配块数 = 指令集::低位零个数(匹配项);
        可用块地址 = 空闲[最佳匹配块数];
        剩余块地址 = 可用块地址 + 块数;
        剩余块数   = 最佳匹配块数 - 块数;
        页地址     = (页 *) (自然数(可用块地址) & 位与得到页地址);
        左边界     = 可用块地址 - 页地址->块组;
        右边界     = 左边界 + 块数 - 1;
        页地址->标记占用(左边界);
        页地址->标记占用(右边界);
        移除(可用块地址, 最佳匹配块数);
        
        若 (剩余块数){
            添加(剩余块地址, 剩余块数);
        }

        回递 可用块地址;
    }
    空 回收(空指针 地址, 自然数 字节数){
        自然数 块对齐分配字节数 = 对齐取整(字节数, 单位分配字节);
        自然数 块数 = 块对齐分配字节数 >> 位移块对齐;

        若 (块对齐分配字节数 >= 页::可分配字节数){
            实际字节数 -= 块对齐分配字节数;
            回递 free(地址);
        }

        链 * 释放块 = (链 *)地址;
        链 * 左邻块;
        链 * 右邻块;
        页 * 页地址 = (页 *)(自然数(释放块) & 位与得到页地址);
        自然数 左边界 = 释放块 - 页地址->块组;
        自然数 右边界 = 左边界 + 块数 - 1;
        自然数 左邻空块长度;
        自然数 右邻空块长度;

        页地址->标记空闲(左边界);
        页地址->标记空闲(右边界);

        左邻空块长度 = 页地址->左邻空块长度(左边界);
        右邻空块长度 = 页地址->右邻空块长度(右边界 + 1);

        若 (左邻空块长度 != 0){
            左邻块 = 释放块 - 左邻空块长度;
            移除(左邻块, 左邻空块长度);
            释放块 = 左邻块;
            块数 += 左邻空块长度;
        }
        若 (右邻空块长度 != 0){
            右邻块 = 释放块 + 块数;
            移除(右邻块, 右邻空块长度);
            块数 += 右邻空块长度;
        }
        若 (块数 == 页::块数){
            页回收(页地址);
            回递;
        }

        添加(释放块, 块数);
    }
私有
    自然数 对齐取整(自然数 字节数, 自然数 对齐空间量) {
        自然数 掩码 = 对齐空间量 - 1;
        回递(字节数 + 掩码) & ~掩码;
    }
    布尔 测试已空并标记非空(自然数 块数){
        回递 指令集::位测试后位置位(& 指示, 块数) == 否;
    }
    空 标记非空(自然数 块数){
        指令集::位测试后位置位(& 指示, 块数);
    }
    空 标记已空(自然数 块数){
        指令集::位测试后位复位(& 指示, 块数);
    }
    
    空 添加(链 * 元素, 自然数 块数){
        若 (测试已空并标记非空(块数)){
            空闲[块数] = 元素;
            元素->前驱 = 元素;
            元素->后继 = 元素;
        }
        非 {
            链 * 首元 = 空闲[块数];
            链 * 尾元 = 首元->前驱;
            首元->前驱 = 元素;
            元素->后继 = 首元;
            尾元->后继 = 元素;
            元素->前驱 = 尾元;
        }
    }
    空 移除(链 * 元素, 自然数 块数){
        链 * 前驱 = 元素->前驱;
        链 * 后继 = 元素->后继;
        
        若 (前驱 == 元素){
            标记已空(块数);
            回递;
        }
        
        前驱->后继 = 后继;
        后继->前驱 = 前驱;
        
        若 (空闲[块数] == 元素){
            空闲[块数] = 后继;
        }
    }
    页 * 页分配(){
        页 * 结果;
        若 (页栈 == 空值) {
            页栈 = (空闲页 *)对齐分配(大页空间量, 大页空间量);
            页栈->首页 = (页 *)页栈;
            页栈->首页->回收中心 = 页栈;
            页栈->指示器 = ~1ull; 静态断言(大页个数 == 64, "[大页个数]需要等于64");
            页栈->前驱 = 页栈;
            页栈->后继 = 页栈;
            实际字节数 += 大页空间量;
        }
        若 (页栈->已空()){
            结果 = (页 *)页栈;
            页栈->首页->回收中心 = 空值;
            页栈 = 页栈->移除();
        }
        非{
            结果 = 页栈->取出();
        }
        回递 结果;
    }
    空 页回收(页 * 页地址) {
        页     *   首页 = (页 * )((自然数)页地址 & 位与得到线性页首页);
        空闲页 *   当前 = (空闲页 *)页地址;
        空闲页 * & 回收中心 = 首页->回收中心;

        若 (回收中心 == 空值) {
            若 (页栈 != 空值) {
                当前->后继 = 页栈;
                当前->前驱 = 页栈->前驱;
                页栈->前驱->后继 = 当前;
                页栈->前驱 = 当前;
            }
            非{
                当前->后继 = 当前;
                当前->前驱 = 当前;
            }
            页栈 = 当前;
            回收中心 = 当前;
            当前->指示器 = 0;
            当前->首页 = 首页;
        }
        非{
            回收中心->放入(页地址 - 首页);
            若 (回收中心->已满()){
                当前 = 回收中心->移除();
                若(回收中心 == 页栈) {
                    页栈 = 当前;
                }
                对齐回收(首页);
                实际字节数 -= 大页空间量;
            }
        }
    }

    U64      指示;
    链     * 空闲[页::块数 + 1];
    空闲页 * 页栈;
};

命名空间{
    分配器 内存;
}

空指针 分配(自然数 字节数) {
    分配指示器++;
    分配字节数 += 字节数;
    回递 内存.分配(字节数);
}
空 回收(空 常量 * 指针, 自然数 字节数) {
    分配指示器--;
    分配字节数 -= 字节数;
    内存.回收((空指针)指针, 字节数);
}