# 接口
C++ 没有显示定义的接口，而常规操作就是通过继承虚基类，实现虚函数... balabala  
我们在学习前人在 OOP 贡献的成果，同时也要妥协抽象带来的开销，虽然虚函数并不完美，但大多场合不会让你觉得鸡肋。  

## 分析

下列代码展示了虚基类的基本用法，按照该方式我们可以实现`针对接口编程`。但自 C++20 以后，
C++ 多了 concept 这么一个用于约束模板的特性，让我们可以通过模板实现同样的功能。  
**BUT** 并不是所有人都愿意把实现暴露在头文件中，他们希望更愿意把实现隐藏到 .cpp 文件中。  
此外，当有很多不同的`派生类`（代指满足该 concept 约束的类）作为该函数的参数时会导致代码膨胀，对于 PC 机也许无伤大雅，但资源匮乏的嵌入式设备可能不会欢迎这种编程实践。所以 concept 暂时不会取代虚基类，当然这也不是 concept 设计的本意，只是它的出现让你多一种选择。
```C++
#define xuser mixc::powerful_cat
#include"mixc.hpp"

struct ax{
    virtual void hi()       = 0;
};

struct bx : ax{
    void hi(){
        xhint("hi, i'm bx");
    }
};

struct cx : ax{
    void hi(){
        xhint("hi, i'm cx");
    }
};

void hi(ax * someone){
    someone->hi();
}

int main(){
    bx b;
    cx c;
    hi(& b);
    hi(& c);
    return 0;
}

```

也有开发人员排斥虚基类，每一个虚基类都会让子类额外消耗指针大小的内存用于存放虚函数表。也就是继承的接口越多，额外的内存开销也就越多，此外虚函数通常难以内联，每次访问虚函数包装的属性时都会产生额外的调用。  
**以上都是抠门 C++ 程序员的老毛病**，C++ 追求高效，但有时候我们可能会被这些琐碎的事情困扰，从而让注意力变得分散。这样的想法并不存在对错，因为人们在接受 OOP 的熏陶时也会怀疑它是否真的像宣传那般的强大，是否可以设计的更好？  

**我们做出这样的思考:**  
- 可不可以把虚函数表移到外边去？
- 不同的接口是否可以组合成一个接口？

每一个接口所需的无非就是成员函数指针和对象指针，假如接口刚好就包含这两个东西，当初始化时从`实现类`（代指满足该接口定义的类，而无需继承关系）中获取 this 指针和对应的成员函数指针，这样就把`派生类`的额外存储负担转移到接口上面。  
新的写法如下：
```C++
#define xuser mixc::powerful_cat
#include"macro/xinterface.hpp"
#include"mixc.hpp"

xinterface(
    xname(isay_hi),
    xfunc(hi, void()) // 定义函数
);

struct bx{
    void hi(){
        xhint("hi, i'm bx");
    }
};

struct cx{
    void hi(){
        xhint("hi, i'm cx");
    }
};

void hi(isay_hi someone){
    someone.hi();
}

int main(){
    bx b;
    cx c;
    hi(b);
    hi(c);
    return 0;
}
```
**作者偷偷告诉你：这种方式也提高了成员函数内联的概率**

## 新式接口的不足
目前它只用函数的参数，虽然它可以做成员变量，但这并不合适。因为实质上它是一个弱指针，它保留的 this 指针的有效性依赖于被指向对象的生命周期，经过之前的讨论，我们也了解到了该模式属于`胖接口`-`瘦实现类`。显然让接口作为字段会类的实例膨胀。
