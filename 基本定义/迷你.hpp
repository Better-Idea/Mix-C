#pragma once
#define 此                     (*this)
#define 此指针                 this
#define 显式                   explicit
#define 引用                   using
#define 引用空间               using namespace
#define 命名空间               namespace
#define 空间量(类型)           sizeof(类型)
#define 比特数(类型)           (sizeof(类型) * 8)
#define 参数数                 sizeof...
#define 删                     delete
#define 解析类型               decltype
#define 运算重载               operator
#define 符号常量               constexpr
#define 模板                   template
#define 类型名称               typename
#define 定义                   typedef
#define 枚举                   enum
#define 枚举体                 enum class
#define 类                     class
#define 结构体                 struct
#define 联合体                 union
#define 主函数                 int main
#define 推导类型               auto
#define 非寄                   volatile
#define 常量                   const
#define 常量修改               mutable
#define 空                     void
#define 外部链接               extern
#define 内联链接               inline
#define 静态                   static
#define 虚                     virtual
#define 友元                   friend
#define 公有                   public:
#define 保护                   protected:
#define 私有                   private:
#define 公有继承               public
#define 保护继承               protected
#define 私有继承               private

#define 开始处                 do
#define 循环                   for
#define 只要                   while

#define 开关                   switch
#define 通向                   case
#define 默认                   default
#define 若                     if
#define 非                     else
#define 或                     else if
#define 跳到                   goto
#define 跳出                   break
#define 下轮                   continue
#define 回递                   return
#define 静态断言               static_assert
#define 无异常申明             noexcept
#define 抛                     throw
#define 共享给                 , 

#ifdef _MSVC_LANG
#define 对齐(n)                __declspec(align(n))
#else
#define 对齐(n)                __attribute((aligned(n)))
#endif

#define 再初始化(类型,引用)    new (取址(引用)) 类型
#define 拼接宏(甲,乙)          甲 ## 乙
#define 二次拼接宏(甲,乙)      拼接宏(甲,乙)
#define 保留字(字节数)         私有 U08 二次拼接宏(保留字节, __LINE__)[字节数]; 公有
#define 保留位(类型,位数)      私有 类型 二次拼接宏(保留位域, __LINE__) : 位数; 公有
#define 比较回调(类型)         [&](类型 常量 & 左, 类型 常量 & 右) -> 整数
#define 正遍历(名称,对象,...)  for(推导类型 名称 = 对象->正遍历器(__VA_ARGS__); 名称.未达尾元(); 名称 = 名称.下一个())
#define 反遍历(名称,对象,...)  for(推导类型 名称 = 对象->反遍历器(__VA_ARGS__); 名称.未达尾元(); 名称 = 名称.下一个())

定义 char                      阿斯克码;
定义 signed char               I08;
定义 short                     I16;
定义 int                       I32;
定义 long long                 I64;
定义 unsigned char             U08;
定义 unsigned short            U16;
定义 unsigned int              U32;
定义 unsigned long long        U64;
定义 float                     F32;
定义 double                    F64;
定义 bool                      布尔;
定义 char16_t                  文字;
定义 void *                    空指针;
定义 const void *              常量空指针;
定义 decltype(nullptr)         空值类型;

#ifdef _M_X64
定义 U64 自然数;
定义 I64 整数;
符号常量 自然数 自然数指数 = 6;
#define 六十四位系统 1
#else
定义 U32 自然数;
定义 I32 整数;
符号常量 自然数 自然数指数 = 5;
#define 三十二位系统 1
#endif

联合体 字节{
    结构体 {
        U08 低 : 4;
        U08 高 : 4;
    };
    字节(U08 值 = '\0') : 
        全字(值){
    }
    运算重载 U08 &(){
        回递 全字;
    }
私有
    U08 全字;
};

联合体 MF32 {
    结构体{
        U32 小数  : 23;
        U32 阶码  : 8;
        U32 符号  : 1;
    };
    F32  值;
    MF32(){}
    MF32(F32 值) {
        此.值 = 值;
    }
    整数 真实阶码() {
        回递 整数(阶码 - 127);
    }
    符号常量 MF32(U32 符号, U32 阶码, U32 小数) : 
        符号(符号), 阶码(阶码), 小数(小数) {
    }
    运算重载 F32() 常量 {
        回递 值;
    }
    运算重载 F32 &() {
        回递 值;
    }
};

联合体 MF64 {
    结构体{
        U64 小数  : 52;
        U64 阶码  : 11;
        U64 符号  : 1;
    };
    F64  值;
    MF64(){}
    MF64(F64 值) {
        此.值 = 值;
    }
    整数 真实阶码() {
        回递 整数(阶码 - 1023);
    }
    符号常量 MF64(U64 符号, U64 阶码, U64 小数) : 
        符号(符号), 阶码(阶码), 小数(小数) {
    }
    运算重载 F64() 常量 {
        回递 值;
    }
    运算重载 F64 &() {
        回递 值;
    }
};

结构体 非数结构{
    友元 布尔 运算重载==(F32 值, 非数结构){
        回递 !(值 == 值);
    }
    友元 布尔 运算重载!=(F32 值, 非数结构){
        回递 (值 == 值);
    }
    友元 布尔 运算重载==(非数结构, F32 值){
        回递 !(值 == 值);
    }
    友元 布尔 运算重载!=(非数结构, F32 值){
        回递 (值 == 值);
    }
    友元 布尔 运算重载==(F64 值, 非数结构){
        回递 !(值 == 值);
    }
    友元 布尔 运算重载!=(F64 值, 非数结构){
        回递 (值 == 值);
    }
    友元 布尔 运算重载==(非数结构, F64 值){
        回递 !(值 == 值);
    }
    友元 布尔 运算重载!=(非数结构, F64 值){
        回递 (值 == 值);
    }
};

结构体 空引用结构{
    模板<类 类型> 友元 布尔 运算重载==(类型 常量 & 值, 空引用结构){
        回递 空指针(&值) == 空引用结构::值;
    }
    模板<类 类型> 友元 布尔 运算重载==(空引用结构, 类型 常量 & 值){
        回递 空指针(&值) == 空引用结构::值;
    }
    模板<类 类型> 友元 布尔 运算重载!=(类型 常量 & 值, 空引用结构){
        回递 空指针(&值) != 空引用结构::值;
    }
    模板<类 类型> 友元 布尔 运算重载!=(空引用结构, 类型 常量 & 值){
        回递 空指针(&值) != 空引用结构::值;
    }
    模板<类 类型> 运算重载 类型 & () 常量 {
        回递 *(类型 *)值;
    }
私有
    静态 空指针 值;
};

模板<类 类型>
结构体 内存块{
    U08 字节[空间量(类型)];
    内存块() : 字节{ 0 } {}
    内存块(类型 常量 & 值) {
        此 = 值;
    }
    空 运算重载=(类型 常量 & 值){
        再初始化(类型, 此)(值);
    }
    运算重载 类型 &(){
        回递 *(类型 *)字节;
    }
    静态 符号常量 自然数 长度 = 空间量(类型);
};

模板<类 类型>
结构体 隐式值{
    模板<类 乙>
    隐式值(乙 常量 & 值) :
        值((类型)(乙 &)值){
    }
    运算重载 类型 &(){
        回递 值;
    }
    推导类型 运算重载->(){
        回递 & 值;
    }
私有
    类型 值;
};

结构体 哑元结构{
    模板<类 ... 参数>
    哑元结构(参数 常量 & ... 列表){}
};

符号常量 推导类型              空值 = nullptr;
符号常量 空引用结构            空引用{};
符号常量 非数结构              非数{};
符号常量 自然数                魔数 = 19961212;
符号常量 自然数                不存在 = 自然数(-1);
符号常量 MF64                  正无穷{ 0ull, 0x7ffull, 0ull };
符号常量 MF64                  负无穷{ 1ull, 0x7ffull, 0ull };
符号常量 布尔                  是 = true;
符号常量 布尔                  否 = false;
符号常量 布尔                  置位态 = true;
符号常量 布尔                  复位态 = false;

#define __PLACEMENT_NEW_INLINE
#ifdef _MSC_VER
void * operator new (size_t Bytes, void * Ptr) noexcept;
#else
void * operator new (unsigned long Bytes, void * Ptr) noexcept;
#endif

自然数 分配平衡指示器();
自然数 已分配字节数();
空 回收(空 常量 * 指针, 自然数 字节数);

模板<类 类型>
内联链接 类型 * 分配() {
    空指针 分配(自然数 字节数);
    回递 (类型 *)分配(空间量(类型));
}

模板<类 类型>
内联链接 类型 * 分配(自然数 元素个数){
    空指针 分配(自然数 字节数);
    回递 (类型 *)分配(元素个数 * 空间量(类型));
}

模板<类 类型, 类 初始化>
内联链接 类型 * 分配(自然数 元素个数, 初始化 常量 & 回调){
    类型 * 内存 = 分配<类型>(元素个数);
    
    循环(自然数 下标 = 0; 下标 < 元素个数; 下标++) {
        ((初始化 &)回调)(内存, 下标);
    }
    回递 内存;
}

模板<类 类型, 类 ... 参数> 
内联链接 类型 * 构造(参数 常量 & ... 列表) {
    空指针 分配(自然数 字节数);
    类型 * 结果 = (类型 *)分配(空间量(类型));
    再初始化(类型, 结果[0])(列表...);
    回递 结果;
}

模板<类 类型>
内联链接 空 回收(类型 * 指针) {
    指针->~类型();
    回收(指针, 空间量(类型));
}

#define 生成(类型) 内联链接 整数 比较(类型 常量 & 左, 类型 常量 & 右) { 回递 左 == 右 ? 0 : 左 > 右 ? 1 : -1; }

生成(I08);
生成(I16);
生成(I32);
生成(I64);
生成(U08);
生成(U16);
生成(U32);
生成(U64);
生成(F32);
生成(F64);
#undef 生成

模板<类 类型>
内联链接 整数 比较(类型 常量 & 左, 类型 常量 & 右) {
    定义 内存块<类型> 块;
    块 & A = 转换<类型, 块>(左);
    块 & B = 转换<类型, 块>(右);
    
    循环(自然数 I = 0; I < A->长度; I++) {
        若 (A->字节[I] != B->字节[I]){
            回递 I08(A->字节[I]) - I08(B->字节[I]);
        }
    }
    回递 0;
}

模板<类 类型>
内联链接 类型 * 取址(类型 常量 & 值){
    结构体 取值容器{
        类型 常量 & 值;
        取值容器(类型 常量 & 值):
            值(值){
        }
    } 容器(值);
    回递 (*(类型 **)&容器);
}

模板<类 源类型, 类 目标类型> 
内联链接 目标类型 & 转换(源类型 常量 & 值) {
    回递 *(目标类型 *)取址(值);
}

模板<类 类型> 
内联链接 空 交换(类型 & 甲, 类型 & 乙) {
    定义 内存块<类型> 块;
    块 A = 转换<类型, 块>(甲);
    块 B = 转换<类型, 块>(乙);
    转换<类型, 块>(乙) = A;
    转换<类型, 块>(甲) = B;
}

模板<类 类型> 
内联链接 空 复制(类型 * 目的, 类型 常量 * 源头, 自然数 个数) {
    类型 * 指针甲 = (类型 *)(目的);
    类型 * 指针乙 = (类型 *)(源头);

    若 (目的 > 源头) {
        只要(个数--) {
            指针甲[个数] = 指针乙[个数];
        }
    }
    非{
        循环(自然数 下标 = 0; 下标 < 个数; 下标++) {
            指针甲[下标] = 指针乙[下标];
        }
    }
}

模板<类 目的类型, 类 源头类型> 
内联链接 空 复制(目的类型 & 目的, 源头类型 常量 & 源头) {
    定义 内存块<目的类型> 块;
    转换<目的类型, 块>(目的) = 转换<源头类型, 块>(源头);
}

模板<类 类型> 
内联链接 空 填充(类型 * 目的, 类型 常量 & 值, 自然数 个数) {
    只要(个数-- > 0) {
        目的[0] = (类型 &)值;
        目的++;
    }
}

模板<类 类型, 类 填充类型> 
内联链接 空 填充(类型 * 目的, 填充类型 值, 自然数 个数) {
    只要(个数-- > 0) {
        目的[0] = (类型 &)值;
        目的++;
    }
}

内联链接 空 清空(空指针 目的, 自然数 字节数) {
    只要 (字节数--) {
        ((U08 *)(目的))[字节数] = 0;
    }
}

模板<类 类型> 
内联链接 空 清空(类型 & 内存) {
    再初始化(内存块<类型>, 内存)();
}
