# 现代 GC
**并不是垃圾语言才需要 GC，而是现在的 GC 并不能令最求极致性能的 C++ 开发者满意。如果说世界上只有两种 GC**
- 那么一种由来已久
- 而另一种，开创时代

```
                                                   +---------------------------+
                                                   | Discrete Memory Allocator |
            +-----------------------+     [1]      +===========================+
[2] ++----- | thread - 0            | <----------- | allocator - 0             | <---++
    ||      |                       |     ++-----> |                           | ----||--++
    ||      +-----------------------+     ||       +---------------------------+     ||  ||
    |+----- | thread - 1            | <---||------ | allocator - 1             | <---+|  ||
    ||      |                       |     |+-----> |                           | ----||--+|
    ||      +-----------------------+     ||       +---------------------------+     ||  ||
    |+----- | ...                   | <---||------ | ...                       | <---+|  ||
    ||      |                       |     |+-----> |                           | ----||--+|
    ||      +-----------------------+     ||       +---------------------------+     ||  ||
    |+----- | thread - n            | <---||------ | allocator - n             | <---+|  ||
    ||      |                       |     |+-----> |                           | ----||--+|
    ||      +-----------------------+     ||       +---------------------------+     ||  ||
    ||                                    ||                                         ||  ||
    ||      +-----------------------+     ||                                         ||  ||
    ||      | Back GC Thread        |     ||                                         ||  ||
    ||      +=======================+     ||                                         ||  ||
    ++----> | - grouping            | ----++ [3]                                     ||  ||
            | - queue               |                                                ||  ||
            | - pile up             |                                                ||  ||
            +-----------------------+                                                ||  ||
                                                                                     ||  ||
            +-----------------------+                                                ||  ||
            | Base Memory Allocator |                                                ||  ||
            +=======================+                                          [0]   ||  ||
            | - sync alloc          | -----------------------------------------------++  ||
            | - sync free           | <--------------------------------------------------++ [4]
            +-----------------------+

==================================== GC Architectural ====================================
```

## 关联部分
- 内存分配器
- 线程
- 引用计数器 + 图论

### 内存分配器
为了提高内存分配回收的吞吐量，我们为每一个线程单独配置了无锁内存分配器（da）。当独立分配器可用内存耗尽时则从底层带锁内存分配器获取大块内存，独立分配器的实现在这里 -> https://github.com/Better-Idea/Mix-C/blob/master/utils/private/tiny_allocator.hpp
- 分配：由前台线程完成
- 释放：委托给后台 GC 线程，在 GC 运行时筛选出可以释放的对象，然后将这些对象使用的内存推送给对应所属线程，所属线程在分配或释放内存时，顺带处理一下来自其他线程推送的释放操作  

### 线程
我们希望堆内存在线程间是平等的，而不是作为某个线程的附属品随着所属线程的消亡而直接释放。  
线程可以一直运行到结束，也可能被类似 terminal_thread 这样的函数劝退。我们保留仍被其他线程引用的内存，并释放无引用者的内存。
- 线程可以实时释放
- 不存在悬挂的引用  
...

## 此 GC 中的概念
### 析构称谓
- 对于 `shared_ptr` 的析构我们称为 `外析构`
- 对于 `shared_ptr` 管理内存对象的析构我们称为 `内析构`
由 `shared_ptr` 的行为可知，所有指向同一个对象的 `shared_ptr` 进行了 `外析构` 后才会执行 `内析构`

### 智能指针称谓
- 如果一个类型的成员存在直接或间接指向该结构本身，我们则称它为 `潜质类型`，否则称它为 `平凡类型`。
`潜质类型` 可能构成环形引用，`平凡类型` 一定不构成环形引用

### 特殊情况
结构嵌套是 `潜质类型` 的特殊情况，下面给出的容器都只是结构嵌套，它们都是先继承 disable_copy 指示无法拷贝构造和直接赋值，再继承 self_management，告诉 GC 这些结构具有兼容标准路由函数签名的自定义的路由函数 routing。这样既能节省内存，又能享受 gc 的便利。  
- [**docker/private/stack**](https://github.com/Better-Idea/Mix-C/tree/master/docker/private/stack.hpp)  
- [**docker/private/queue**](https://github.com/Better-Idea/Mix-C/tree/master/docker/private/queue.hpp)  
- [**docker/private/hashmap**](https://github.com/Better-Idea/Mix-C/tree/master/docker/private/hashmap.hpp)

其实上述容器的元素完全可以用 `shared<T>` 构成，但我们为了降低不必要的开销而选择自己管理这些类型。  
如果把上述结构中递归定义当作结构嵌套对待的话，那这些节点是不能直接暴露给外部的，因为所有外部引用该节点的指针皆为弱指针，随着指向的节点在内部被释放而无效。  
  
但如果使用 `shared<T>` 就可以共享这些节点了，比如你可以把一个链表节点共享给另一个链表。所以我们没有限制死一定要用 gc 的那一套，也可以自定义 routing 函数来提供显式的 gc 路由策略。  

### 类型环
- 环上任意类型都存在两两直接或间接指向关系，这里特指由 `潜质类型` 本身和能构成回路的子节点构成的类型集合
- `类型环` 是编译期的产物，其存在的意义非凡，它为 GC 在运行时路由一个 `潜质类型` 提供启发，减少经过无用的节点的次数，降低了路由的规模，本质是一个剪枝操作

### 图论引申
- `出度和`：同一 `类型环` 上所有能构成回路的边数
- `入度和`：同一 `类型环` 上所有回路节点的引用计数总和
- `出度和` 是不会大于 `入度和` 的，当 `出度和` 等于 `入度和` 时，此时这个图就形成了一个孤岛
- TODO：补充具体的例子以帮助理解 =======================================

### 拓扑关系
- `平凡连接`：`平凡类型` 包含 `平凡类型`
- `吊挂连接`：`平凡类型` 包含 `潜质类型`
- `外延连接`：`潜质类型` 包含 `平凡类型`
- `潜质连接`：`潜质类型` 包含同一 `类型环` 上的 `潜质类型`
- `复合连接`：`潜质类型` 包含非同一 `类型环` 上的 `潜质类型`
- TODO：补充具体的例子以帮助理解 =======================================

### 析构方法
- 任何时候 `外析构` 导致引用计数器为 0 时就可以进行 `内析构`
- `内析构` 时，先标记为处于析构态，然后析构，最后释放内存。如果已经处于析构态则不再执行析构和释放操作
- 当 `外析构` 时引用计数器不为 0 但该结构属于 `潜质类型`，此时需要从根节点出发遍历属于 `类型环` 上的所有节点，如果经计算得出该结构的 `出度和` 等于 `入度和`，则可以进入 `内析构` 步骤，否则不可以

## 复杂度说明
每当环对象在栈上析构时总要遍历一次所有可能在环上的节点，复杂度趋近于栈上环对象个数 m 与 环上节点数 n 的乘积 O(m * n)，也许你觉得有点亏。  
但你想一下，对于被 shared_ptr 管理的非环对象要经过引用计数次析构才能真正释放一个节点的内存，也就是 m 个对象持有同一份内存，要完成这次释放的累计复杂度为 O(m)，但它为什么还要被认为是 O(1) 的复杂度，因为大家是从该结构单次析构的角度来看待，同样对于环对象而言，它单次析构的复杂度为 O(n)  
而对于环对象，需要 O(m * n) 释放 n 个节点的内存，也就是平均每个节点复杂度为 O(m)，而在面向对象语言中，我们大多创建的对象是被堆引用，而栈上的环对象则较少，也就是一个环跨根节点较少的情况，该算法的复杂度较低。  
**作者以联通客服打电话告诉你这个套餐每天只要 1 块钱的方式，让你心里能更接受一点这个套餐每月大概要 30 块钱的现实。**  
而作者往往没什么人打电话给 TA，而 TA 也没有什么要打电话的人，TA 希望最好能让电话停机，等有需要的时候立即激活。  
  
而该 GC 算法已经支持该套餐，在环对象析构时可以不必直接走判断是否可以释放内存的路了，把 this 指针和 release 函数指针打包推送给后台。后台 GC 队列先堆积一波打包好的 this/release，到达阈值后，通过从后往前根据 this 指针去重，并把相应的引用计数器减一。对于 `潜质类型` 而言，先让大量节点计数器减一可以更早的让其外部引用和为 0，也就是只要一次遍历就可以释放整个环。  

去重的实现也非常简单，就是复用了引用计数器中的一个位，如果在去重时发现该位是复位态，先将该位置位，并将该元素保留，下一次碰到同一个地址时将重复的地址置空
```
对于 push 的地址
push 0x1000
push 0x1000
push 0x1010
push 0x1020
push 0x1020 <- 第一次碰到，再碰到相同的地址就置为 nullptr
push 0x1010 <- 第一次碰到，再碰到相同的地址就置为 nullptr
push 0x1000 <- 第一次碰到，再碰到相同的地址就置为 nullptr

去重后的顺序如下(从后往前排)：
nullptr
nullptr
nullptr
nullptr
0x1020
0x1010
0x1000

去重完成后，就是路由阶段，如果碰到 nullptr 的地址就跳过，否则就照常执行
```

## 可用性探讨
https://github.com/Better-Idea/Mix-C/blob/master/discuss/talk_about_gc.cpp  

## 展望
**Back GC Thread 只是作为一个代称，代指 GC 方，可以根据需求决定是否需要用多线程来管理**  

如果你想实时释放内存，或者在乎析构的顺序，那么大可每次都等待 GC 完成清理，但并不要求前台等待 GC 响应完所有的请求。
```C++
...
{
    shared<ax> a0 = default_init_by;
    {
        shared<ax> a1 = a0;
        a1->self = a0;
    }
} /* a0 和 a1 共享内存理论上的释放点
   * 可以把释放操作委托给后台线程，所谓的在此处等待 GC 完成即在[此时间点]上，
   * 所有 push 到 GC 中的请求全部完成即可
   * 在[此时间点]后 push 的请求将不会阻塞前台
   * 例如：
   *    Thread A | Thread B
   * 0  push 0   | ..
   * 1  ..       | push 1
   * 2  push 2   | wait
   * 3  push 3   | ...
   * Thread B 在时间点 2 等待 gc(假设 push 2 在 wait 后执行)，那么只要 gc 处理完了 push 0~1 就可以恢复执行了
   */
...
```
