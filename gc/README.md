# 现代 GC
**并不是垃圾语言才需要 GC，而是现在的 GC 并不能令最求极致性能的 C++ 开发者满意。如果说世界上只有两种 GC**
- 那么一种由来已久
- 而另一种，开创时代

```
                                                   +---------------------------+
                                                   | Discrete Memory Allocator |
            +-----------------------+     [1]      +===========================+
[2] ++----- | thread - 0            | <----------- | allocator - 0             | <---++
    ||      |                       |     ++-----> |                           | ----||--++
    ||      +-----------------------+     ||       +---------------------------+     ||  ||
    |+----- | thread - 1            | <---||------ | allocator - 1             | <---+|  ||
    ||      |                       |     |+-----> |                           | ----||--+|
    ||      +-----------------------+     ||       +---------------------------+     ||  ||
    |+----- | ...                   | <---||------ | ...                       | <---+|  ||
    ||      |                       |     |+-----> |                           | ----||--+|
    ||      +-----------------------+     ||       +---------------------------+     ||  ||
    |+----- | thread - n            | <---||------ | allocator - n             | <---+|  ||
    ||      |                       |     |+-----> |                           | ----||--+|
    ||      +-----------------------+     ||       +---------------------------+     ||  ||
    ||                                    ||                                         ||  ||
    ||      +-----------------------+     ||                                         ||  ||
    ||      | Back GC Thread        |     ||                                         ||  ||
    ||      +=======================+     ||                                         ||  ||
    ++----> | - grouping            | ----++ [3]                                     ||  ||
            | - queue               |                                                ||  ||
            | - pile up             |                                                ||  ||
            +-----------------------+                                                ||  ||
                                                                                     ||  ||
            +-----------------------+                                                ||  ||
            | Base Memory Allocator |                                                ||  ||
            +=======================+                                          [0]   ||  ||
            | - sync alloc          | -----------------------------------------------++  ||
            | - sync free           | <--------------------------------------------------++ [4]
            +-----------------------+

==================================== GC Architectural ====================================
```

## 关联部分
- 内存分配器
- 线程
- 引用计数器 + 图论

### 内存分配器
为了提高内存分配回收的吞吐量，我们为每一个线程单独配置了无锁内存分配器（da）。当独立分配器可用内存耗尽时则从底层带锁内存分配器获取大块内存，独立分配器的实现在这里 -> https://github.com/Better-Idea/Mix-C/blob/master/memory/private/tiny_allocator.hpp
- 分配：由前台线程完成
- 释放：委托给后台 GC 线程  

### 线程
我们希望堆内存在线程间是平等的，而不是作为某个线程的附属品随着所属线程的消亡而直接释放。  
线程可以一直运行到结束，也可能被类似 terminal_thread 这样的函数劝退。我们保留仍被其他线程引用的内存，并释放无引用者的内存。
- 线程可以实时释放
- 不存在悬挂的引用  
...

### 引用计数器 + 图论
原始的引用计数器解 shared_ptr（sp）决不了环形引用问题，但结合图论的引用计数器就与众不同，这里暂且叫它 shared_ptr with guide (spg)。  
思路：如果一个对象不存在环形引用结构（这种结构是一般在编译期可以得出），那么 spg 的行为和普通 sp 大同小异（没有额外的行为），否则我们需要通过元编程计算出能从 spg 出发并能再次抵达 spg 的**类型集合** guide。  
guide 存在的意义非凡，它在编译期为 gc 路由一个具有环形引用的对象（下文称 环对象）提供启发，减少经过无用的节点的次数，降低了路由的规模。  
  
**概念一：我们判断能否(不是是否)构成环形引用的标准是：从一个类型出发，路由成员类型，能再次回到该类型本身**  
首先我们要达成一致的观点：guide 只是告诉 gc，哪些类型具有环形结构的潜质，能不能真正构成回路还得靠 gc 在运行时路由这些类型的节点。  

下面这些都只是结构嵌套，先继承 disable_copy 指示无法拷贝构造和直接赋值，再继承 self_management，告诉 gc 这些结构具有兼容标准路由函数签名的自定义的路由函数 routing。这样既能节省内存，又能享受 gc 的便利。  
- [**docker/private/stack**](https://github.com/Better-Idea/Mix-C/tree/master/docker/private/stack.hpp)  
- [**docker/private/queue**](https://github.com/Better-Idea/Mix-C/tree/master/docker/private/queue.hpp)  
- [**docker/private/hashmap**](https://github.com/Better-Idea/Mix-C/tree/master/docker/private/hashmap.hpp)  
  
其实上述结构也完全可以用 mixc::shared_ptr 构成，但我们为了节省内存，降低不必要的开销而选择自己管理这些类型。  
如果把上述结构中递归定义当作结构嵌套看的话，那这些节点是不能直接暴露给外部的，因为所有外部引用该节点的指针皆为弱指针，随着指向的节点在内部被释放而无效。  
  
但如果使用 shared_ptr 就可以共享这些节点了，比如你可以把一个链表节点共享给另一个链表。所以我们没有限制死一定要用 gc 的那一套，也可以自定义 routing 函数来提供显式的 gc 路由策略。  
  
回归正题：  
我们这里以简单的例子示意环形引用。  
```C++
// 假如 gcof(type) 可以在编译期得到 type 具有环形引用关系节点集合 guide
// 那么 gcof(spg<foo>) 将得到 guide = { bar, foo, spg<bar>, spg<foo> }
// 这里的 guide 用于指导 gc 哪些类型可能构成环，哪些类型一定不存在环
// 其中 spg<int> 被排除在外，因为它并不在环上

struct ax{
    spg<ax> a;              // 自环
};

struct bar;
struct foo{
    spg<bar> b;             // 互环
    spg<int> i;
};

struct bar{
    spg<foo> f;             // 互环
};

...
{
    spg<foo> f{init_now};   // 分配内存
    spg<bar> b{init_now};   // 分配内存
    f.b = b;
    b.f = f;                // 互相指向，构成环
}

...

```

**概念二：对于一个闭合有向图出度和等于入度和**  
**触发条件：满足概念一中定义的环对象条件**

我们定义一个节点的引用数为入度，能抵达根节点的子成员数为该节点出度，由以上概念可知，出度总和是不会大于入度总和的，当一个节点存在外部引用时，会使得出度总和小于入度总和，此时我们可以通过计算该闭合有向图的出入度差是否为 0 来决定是否可以释放根节点。  
  
我们不妨把一个节点抽象成以下结构
```
+------------- 外部引用 ---+------------- 引用计数
|                          |
|      +------ 环内引用 ---+
|      |
V      V
+------+
| Node | -------------------------------> 环内指向
+------+
```
如果一个对象不具有环形结构，即使它包含存在环对象也不影响释放操作，因为被 mixc::shared_ptr 管理的非环对象的行为是和 std::shared_ptr 保持一致的，在包含环对象的非环对象析构时会触发环对象对应的析构操作。  
  
一个非环指向包含环对象会让环对象的引用计数加一，而对于该类型的计数属于外部引用的范畴。也就是说，只要该非环对象存活，那么它指向的环对象一定存活。如果该环处于悬挂状态，那么在该环最后一个悬挂点析构时也就跟着析构了。  

概念二所表述的内容其实就是：  
SUM(引用计数) == SUM(环内指向) == SUM(环内引用)。  
SUM(引用计数器) == SUM(入度)  
SUM(环内指向) == SUM(出度)  

如果环上**所有**节点的`外部引用`数等于 0，那么在环上的所有成员都可以释放。反之，只要**有一个**在环上的节点外部引用数不等于 0，那么该环都是不能释放的。  
而`环内指向`指的是当前节点能再次回到根节点的成员变量个数，尽管有些成员变量的类型属于 guide 类型集合，但并不一定能从它回到根节点，比如该节点指向空指针，或者最终通往指向空指针的路径，我们把不能通往根节点的路径称为死路，死路在该算法对应的有向图中可以当它不存在。  
  
在 gc 运行时路由的中，它可能会碰到已经经过的节点，虽然 gc 不会继续再走这条老路，但这些重复经过的节点暂时还不知道存不存在通往根节点的路径，所以每经过一次这样的节点，让其访问计时器加一，然后绕道继续路由。等到回溯到此节点时发现它存在通往根节点的活路，那么此节点的访问计数器代表的就是环内引用。  
当然也存在这种情况，当前要经过的节点已经确定可以通往根节点，那么就可以往出度入度差中减去一。

## 复杂度说明
每当环对象在栈上析构时总要遍历一次所有可能在环上的节点，复杂度趋近于栈上环对象个数 m 与 环上节点数 n 的乘积 O(m * n)，也许你觉得有点亏。  
但你想一下，对于被 shared_ptr 管理的非环对象要经过引用计数次析构才能真正释放一个节点的内存，也就是 m 个对象持有同一份内存，要完成这次释放的累计复杂度为 O(m)，但它为什么还要被认为是 O(1) 的复杂度，因为大家是从该结构单次析构的角度来看待，同样对于环对象而言，它单次析构的复杂度为 O(n)  
而对于环对象，需要 O(m * n) 释放 n 个节点的内存，也就是平均每个节点复杂度为 O(m)，而在面向对象语言中，我们大多创建的对象是被堆引用，而栈上的环对象则较少，也就是一个环跨根节点较少的情况，该算法的复杂度较低。  
**作者以联通客服打电话告诉你这个套餐每天只要 1 块钱的方式，让你心里能更接受一点这个套餐每月大概要 30 块钱的现实。**  
而作者往往没什么人打电话给 TA，而 TA 也没有什么要打电话的人，TA 希望最好能让电话停机，等有需要的时候立即激活。  
  
而该 gc 算法也将支持该套餐，在环对象析构时可以不必直接走判断是否可以释放内存的路了，把 this 指针和 routing 成员函数指针打包推送给后台。后台 gc 先堆积一波打包好的 this/routing pair，到达阈值后，通过 hashmap 将 pair 列表从后往前根据 this 指针去重，并把相应的引用计数器减一。对于环对象而言，先让大量节点计数器减一可以更早的让其外部引用和为 0，也就是只要一次遍历就可以释放整个环。  

有人觉得 mark_sweep 可能更快，但它每次整理都要遍历所有对象，mark_sweep O(n) 的复杂度中的 n 和 mixc::shared_ptr 中的 O(m*n) 中的 n 可不是同一个 n  

## 可用性探讨
https://github.com/Better-Idea/Mix-C/blob/master/discuss/talk_about_gc.cpp  

## 展望
**Back GC Thread 只是作为一个代称，代指 gc 方，可以根据需求决定是否需要用多线程来管理**  

如果你想实时释放内存，或者在乎析构的顺序，那么大可每次都等待 gc 完成清理，但并不要求前台等待 gc 响应完所有的请求。
```C++
...
{
    shared_ptr<ax> a0(init_now, ... /* push some args for initialize*/);
    {
        shared_ptr<ax> a1 = a0;
        a1->self = a0;
    }
} /* a0 和 a1 共享内存理论上的释放点
   * 可以把释放操作委托给后台线程，所谓的在此处等待 gc 完成即在[此时间点]上，所有 push 到 gc 中的请求全部完成即可
   * 在[此时间点]后 push 的请求将不会阻塞前台
   * 例如：
   *    Thread A | Thread B
   * 0  push 0   | ..
   * 1  ..       | push 1
   * 2  push 2   | wait
   * 3  push 3   | ...
   * Thread B 在时间点 2 等待 gc(假设 push 2 在 wait 后执行)，那么只要 gc 处理完了 push 0~1 就可以恢复执行了
   */
...
```

如果你不需要实时释放，gc 不会傻傻的一遍又一遍单独遍历一个环对象。push 到 gc 的请求会被堆积起来，并批量先让引用计数器减一，在去重后再遍历，去重后的列表会保持释放的顺序。  
```
对于 push 的地址
push 0x1000
push 0x1000
push 0x1010
push 0x1020
push 0x1020
push 0x1010
push 0x1000

去重后的顺序如下(从后往前排)：
0x1020
0x1010
0x1000
```
