# 现代 GC
**并不是垃圾语言才需要 GC，而是现在的 GC 并不能令最求极致性能的 C++ 开发者满意。如果说世界上只有两种 GC**
- 那么一种由来已久
- 而另一种，开创时代

```
                                                   +---------------------------+
                                                   | Discrete Memory Allocator |
            +-----------------------+     [1]      +===========================+
[2] ++----- | thread - 0            | <----------- | allocator - 0             | <---++
    ||      |                       |     ++-----> |                           | ----||--++
    ||      +-----------------------+     ||       +---------------------------+     ||  ||
    |+----- | thread - 1            | <---||------ | allocator - 1             | <---+|  ||
    ||      |                       |     |+-----> |                           | ----||--+|
    ||      +-----------------------+     ||       +---------------------------+     ||  ||
    |+----- | ...                   | <---||------ | ...                       | <---+|  ||
    ||      |                       |     |+-----> |                           | ----||--+|
    ||      +-----------------------+     ||       +---------------------------+     ||  ||
    |+----- | thread - n            | <---||-----> | allocator - n             | <---+|  ||
    ||      |                       |     |+-----> |                           | ----||--+|
    ||      +-----------------------+     ||       +---------------------------+     ||  ||
    ||                                    ||                                         ||  ||
    ||      +-----------------------+     ||                                         ||  ||
    ||      | Back GC Thread        |     ||                                         ||  ||
    ||      +=======================+     ||                                         ||  ||
    ++----> | - grouping            | ----++ [3]                                     ||  ||
            | - queue               |                                                ||  ||
            | - pile up             |                                                ||  ||
            +-----------------------+                                                ||  ||
                                                                                     ||  ||
            +-----------------------+                                                ||  ||
            | Base Memory Allocator |                                                ||  ||
            +=======================+                                          [0]   ||  ||
            | - sync alloc          | -----------------------------------------------++  ||
            | - sync free           | <--------------------------------------------------++ [4]
            +-----------------------+

==================================== GC Architectural ====================================
```

## 关联部分
- 内存分配器
- 线程
- 引用计数器 + 图论

### 内存分配器
为了提高内存分配回收的吞吐量，我们为每一个线程单独配置了无锁内存分配器（da）。当独立分配器可用内存耗尽时则从底层带锁内存分配器获取大块内存
- 分配：由前台线程完成
- 释放：委托给后台 GC 线程  
...

### 线程
我们希望堆内存在线程间是平等的，而不是作为某个线程的附属品随着所属线程的消亡而直接释放。  
线程可以一直运行到结束，也可能被类似 terminal_thread 这样的函数劝退。我们保留仍被其他线程引用的内存，并释放无引用者的内存。
- 线程可以实时释放
- 不存在悬挂的引用  
...

### 引用计数器 + 图论
原始的引用计数器解 shared_ptr（sp）决不了环形引用问题，但结合图论的引用计数器就与众不同，这里暂且叫它 shared_ptr with guide (spg)。  
思路：如果一个对象不存在环形引用结构（这种结构是一般在编译期可以得出），那么 spg 的行为和普通 sp 大同小异，否则我们需要通过元编程计算出能从 spg 出发并能再次抵达 spg 的类型集合 guide。

```C++
// 假如 gcof(type) 可以在编译期得到 type 构成环形引用的节点集合 guide
// 那么 gcof(spg<foo>) 将得到 guide = { spg<bar>, spg<foo> }
// 其中 spg<int> 被排除在外，应为它并不在环上

struct bar;
struct foo{
    spg<bar> b;
    spg<int> i;
};

struct bar{
    spg<foo> f;
};

```
guide 存在的意义非凡，它为 GC 路由一个具有环形引用的对象（下文称 环对象）提供启发，减少经过无用的节点的次数，降低了路由的规模。  
  
**图论基本概念：对于一个闭合有向图出度和等于入度和**  
  
我们定义一个节点的引用数为入度，能抵达根节点的子成员数为该节点出度，由以上概念可知，出度总和是不会大于入度总和的，当一个节点存在外部引用时，会使得出度总和小于入度总和，此时我们可以通过计算该闭合有向图的出入度差是否为 0 来决定是否可以释放根节点
