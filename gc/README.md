# 现代 GC
**并不是垃圾语言才需要 GC，而是现在的 GC 并不能令最求极致性能的 C++ 开发者满意。如果说世界上只有两种 GC**
- 那么一种由来已久
- 而另一种，开创时代

```
                                                   +---------------------------+
                                                   | Discrete Memory Allocator |
            +-----------------------+     [1]      +===========================+
[2] ++----- | thread - 0            | <----------- | allocator - 0             | <---++
    ||      |                       |     ++-----> |                           | ----||--++
    ||      +-----------------------+     ||       +---------------------------+     ||  ||
    |+----- | thread - 1            | <---||------ | allocator - 1             | <---+|  ||
    ||      |                       |     |+-----> |                           | ----||--+|
    ||      +-----------------------+     ||       +---------------------------+     ||  ||
    |+----- | ...                   | <---||------ | ...                       | <---+|  ||
    ||      |                       |     |+-----> |                           | ----||--+|
    ||      +-----------------------+     ||       +---------------------------+     ||  ||
    |+----- | thread - n            | <---||------ | allocator - n             | <---+|  ||
    ||      |                       |     |+-----> |                           | ----||--+|
    ||      +-----------------------+     ||       +---------------------------+     ||  ||
    ||                                    ||                                         ||  ||
    ||      +-----------------------+     ||                                         ||  ||
    ||      | Back GC Thread        |     ||                                         ||  ||
    ||      +=======================+     ||                                         ||  ||
    ++----> | - grouping            | ----++ [3]                                     ||  ||
            | - queue               |                                                ||  ||
            | - pile up             |                                                ||  ||
            +-----------------------+                                                ||  ||
                                                                                     ||  ||
            +-----------------------+                                                ||  ||
            | Base Memory Allocator |                                                ||  ||
            +=======================+                                          [0]   ||  ||
            | - sync alloc          | -----------------------------------------------++  ||
            | - sync free           | <--------------------------------------------------++ [4]
            +-----------------------+

==================================== GC Architectural ====================================
```

## 关联部分
- 内存分配器
- 线程
- 引用计数器 + 图论

### 内存分配器
为了提高内存分配回收的吞吐量，我们为每一个线程单独配置了无锁内存分配器（da）。当独立分配器可用内存耗尽时则从底层带锁内存分配器获取大块内存，独立分配器的实现在这里 -> https://github.com/Better-Idea/Mix-C/blob/master/memory/private/tiny_allocator.hpp
- 分配：由前台线程完成
- 释放：委托给后台 GC 线程  

### 线程
我们希望堆内存在线程间是平等的，而不是作为某个线程的附属品随着所属线程的消亡而直接释放。  
线程可以一直运行到结束，也可能被类似 terminal_thread 这样的函数劝退。我们保留仍被其他线程引用的内存，并释放无引用者的内存。
- 线程可以实时释放
- 不存在悬挂的引用  
...

### 引用计数器 + 图论
原始的引用计数器解 shared_ptr（sp）决不了环形引用问题，但结合图论的引用计数器就与众不同，这里暂且叫它 shared_ptr with guide (spg)。  
思路：如果一个对象不存在环形引用结构（这种结构是一般在编译期可以得出），那么 spg 的行为和普通 sp 大同小异（没有额外的行为），否则我们需要通过元编程计算出能从 spg 出发并能再次抵达 spg 的**类型集合** guide。  
guide 存在的意义非凡，它为 gc 路由一个具有环形引用的对象（下文称 环对象）提供启发，减少经过无用的节点的次数，降低了路由的规模，该模块就通过元编程实现了这一功能。  
  
**我们判断能否(不是是否)构成环形引用的标准是：从一个类型出发，路由成员类型，能再次回到该类型本身**

```C++
// 假如 gcof(type) 可以在编译期得到 type 构成环形引用的类型节点集合 guide
// 那么 gcof(spg<foo>) 将得到 guide = { bar, foo, spg<bar>, spg<foo> }
// 其中 spg<int> 被排除在外，因为它并不在环上

struct ax{
    spg<ax> a;          // 自环
};

struct bar;
struct foo{
    spg<bar> b;         // 互环
    spg<int> i;
};

struct bar{
    spg<foo> f;         // 互环
};

...
{
    spg<foo> f(ini_now); // 分配内存
    spg<bar> b(ini_now); // 分配内存
    f.b = b;
    b.f = f;             // 互相指向，构成环
}
// 作者小声 bb：实际中环形引用可没有这么直接，该算法就是用来解决 unique_ptr 和 shared_ptr 解决不了的问题的
...

```

**图论基本概念：对于一个闭合有向图出度和等于入度和**  
  
我们定义一个节点的引用数为入度，能抵达根节点的子成员数为该节点出度，由以上概念可知，出度总和是不会大于入度总和的，当一个节点存在外部引用时，会使得出度总和小于入度总和，此时我们可以通过计算该闭合有向图的出入度差是否为 0 来决定是否可以释放根节点  

我们不妨把一个节点抽象成以下结构
```
+------------- 外部引用 ---+------------- 引用计数
|                          |
|      +------ 环内引用 ---+
|      |
V      V
+------+
| Node | -------------------------------> 环内指向
+------+
```
如果环上**所有**节点的`外部引用`数等于 0，那么在环上的所有成员都可以释放。反之，只要**有一个**在环上的节点外部引用数不等于 0，那么该环都是不能释放的。  
而`环内指向`指的是当前节点能再次回到根节点的成员变量个数，尽管有些成员变量的类型属于 guide 类型集合，但并不一定能从它回到根节点，比如该变量指向空指针，或者最终通往指向空指针的路径。

## 可用性探讨
https://github.com/Better-Idea/Mix-C/blob/master/discuss/talk_about_gc.cpp

## 展望
**Back GC Thread 只是作为一个代称，代指 gc 方，可以根据需求决定是否需要用多线程来管理**  

如果你想实时释放内存，或者在乎析构的顺序，那么大可每次都等待 gc 完成清理，但并不要求前台等待 gc 响应完所有的请求。
```C++
...
{
    shared_ptr<ax> a0(ini_now, ... /* push some args for initialize*/);
    {
        shared_ptr<ax> a1 = a0;
        a1->self = a0;
    }
} /* a0 和 a1 共享内存理论上的释放点
   * 可以把释放操作委托给后台线程，所谓的在此处等待 gc 完成即在[此时间点]上，所有 push 到 gc 中的请求全部完成即可
   * 在[此时间点]后 push 的请求将不会阻塞前台
   * 例如：
   *    Thread A | Thread B
   * 0  push 0   | ..
   * 1  ..       | push 1
   * 2  push 2   | wait
   * 3  push 3   | ...
   * Thread B 在时间点 2 等待 gc(假设 push 2 在 wait 后执行)，那么只要 gc 处理完了 push 0~1 就可以恢复执行了
   */
...
```

如果你不需要实时释放，gc 不会傻傻的一遍又一遍单独遍历一个环对象。push 到 gc 的请求会被堆积起来，并批量先让引用计数器减一，在去重后再遍历，去重后的列表会保持释放的顺序。  
```
对于 push 的地址
push 0x1000
push 0x1000
push 0x1010
push 0x1020
push 0x1020
push 0x1010
push 0x1000

去重后的顺序如下(从后往前排)：
0x1020
0x1010
0x1000
```
