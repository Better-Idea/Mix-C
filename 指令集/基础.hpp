#pragma once
#include"基本定义/迷你.hpp"
#include<x86intrin.h>
#include<atomic>

命名空间 指令集 {
    #ifdef 六十四位系统
        内联链接 U64 加法(U64 * 低64位, U64 甲, U64 乙, U64 进位 = 0) {
            回递 (U64)_addcarry_u64(U08(进位), 甲, 乙, 低64位);
        }
        内联链接 U64 减法(U64 * 低64位, U64 甲, U64 乙, U64 借位 = 0) {
            回递 (U64)_subborrow_u64(U08(借位), 甲, 乙, 低64位);
        }
        内联链接 U64 乘法(U64 * 低64位, U64 甲, U64 乙) {
            U64 高64位;
            低64位[0] = _mulx_u64(甲, 乙, & 高64位);
            回递 高64位;
        }
        内联链接 U64 除法(U64 * 低64位, U64 甲, U64 乙) {
            低64位[0] = 甲 / 乙;
            回递 甲 % 乙;
        }
        内联链接 I64 乘法(I64 * 低64位, I64 甲, I64 乙) {
            I64 高64位;
            asm(""::"a"(甲),"d"(乙));
            asm("imul %%rdx":"=d"(高64位), "=a"(低64位[0]));
            回递 高64位;
        }
        内联链接 I64 除法(I64 * 低64位, I64 甲, I64 乙) {
            低64位[0] = 甲 / 乙;
            回递 甲 % 乙;
        }

    #elif defined 三十二位系统
        #error "待实现"

        // 内联链接 U64 加法(U64 & 低64位, U64 甲, U64 乙) {
        //     回递 加法(低64位, 甲, 乙, 0);
        // }
        // 内联链接 U64 加法(U64 & 低64位, U64 甲, U64 乙, U64 进位) {
        //     字化对象<U64, U32> C = 低64位;
        //     字化对象<U64, U32> A = 甲;
        //     字化对象<U64, U32> B = 乙;
        //     U08 CF = (U08)进位;
        //     CF = _addcarry_u32(CF, A[0], B[0], & C[0]);
        //     CF = _addcarry_u32(CF, A[1], B[1], & C[1]);
        //     回递 (U64)CF;
        // }
        // 内联链接 U64 减法(U64 & 低64位, U64 甲, U64 乙) {
        //     回递 减法(低64位, 甲, 乙, 1);
        // }
        // 内联链接 U64 减法(U64 & 低64位, U64 甲, U64 乙, U64 借位) {
        //     字化对象<U64, U32> C = 低64位;
        //     字化对象<U64, U32> A = 甲;
        //     字化对象<U64, U32> B = 乙;
        //     U08 CF = (U08)借位;
        //     CF = _subborrow_u32(CF, A[0], B[0], & C[0]);
        //     CF = _subborrow_u32(CF, A[1], B[1], & C[1]);
        //     回递 (U64)CF;
        // }
        // 内联链接 U64 乘法(U64 & 低64位, U64 甲, U64 乙) {
        //     U64 高64位;
        //     字化对象<U64, U32> Ta = 甲;
        //     字化对象<U64, U32> Tb = 乙;
        //     U32 A = Ta[0];
        //     U32 B = Ta[1];
        //     U32 C = Tb[0];
        //     U32 D = Tb[1];
        //     U32 L[4];
        //     U32 H[4];
        //     U08 CF = 0;

        //     H[0] = _mulx_u32(A, C, & L[0]);
        //     H[1] = _mulx_u32(A, D, & L[1]);
        //     H[2] = _mulx_u32(B, C, & L[2]);
        //     H[3] = _mulx_u32(B, D, & L[3]);

        //     CF = _addcarry_u32(CF, H[0], L[1], L + 1);
        //     CF = _addcarry_u32(CF, L[1], L[2], L + 1);
        //     CF = _addcarry_u32(CF, H[1], H[2], H + 2);
        //     CF = _addcarry_u32(CF, H[2], L[3], H + 2);
        //     H[3] += CF;

        //     低64位 = (U64)L[1] << 32 | L[0];
        //     高64位 = (U64)H[1] << 32 | H[0];
        //     回递 高64位;
        // }
        // 内联链接 U64 除法(U64 & 低64位, U64 甲, U64 乙) {
        //     低64位 = 甲 / 乙;
        //     回递 甲 % 乙;
        // }
        // 内联链接 I64 乘法(I64 & 低64位, I64 甲, I64 乙) {
        //     U64 L;
        //     U64 H;
        //     U64 CF = 0;
        //     I64 高64位;
        //     H = 乘法(L, U64(甲), U64(乙));

        //     若 (位测试(U64(甲), 63)) {
        //         若 (位测试(U64(乙), 63)) { //负负得正
        //             CF = 减法(L, CF, L);
        //             CF = 减法(H, CF, H);
        //         }
        //         非{
        //             H |= U64(-1) << 最高置位位索引(H);
        //         }
        //     }
        //     非{
        //         若 (位测试(U64(乙), 63)) {
        //             H |= U64(-1) << 最高置位位索引(H);
        //         }
        //     }

        //     低64位 = (I64)L;
        //     高64位 = (I64)H;
        //     回递 高64位;
        // }
        // 内联链接 I64 除法(I64 & 低64位, I64 甲, I64 乙) {
        //     低64位 = 甲 / 乙;
        //     回递 甲 % 乙;
        // }
        // 内联链接 布尔 位测试(U64 值, 自然数 下标) {
        //     字化对象<U64, U32> T = 值;
        //     回递 下标 >= 32 ? 
        //         位测试(T[1], 下标 - 32) : 
        //         位测试(T[0], 下标);
        // }
        // 内联链接 布尔 位测试后位取反(U64 & 值, 自然数 下标) {
        //     字化对象<U64, U32> T = 值;
        //     回递 下标 >= 32 ? 
        //         位测试后位取反(T[1], 下标 - 32) : 
        //         位测试后位取反(T[0], 下标);
        // }
        // 内联链接 布尔 位测试后位置位(U64 & 值, 自然数 下标) {
        //     字化对象<U64, U32> T = 值;
        //     回递 下标 >= 32 ?
        //         位测试后位置位(T[1], 下标 - 32) :
        //         位测试后位置位(T[0], 下标);
        // }
        // 内联链接 布尔 位测试后位复位(U64 & 值, 自然数 下标) {
        //     字化对象<U64, U32> T = 值;
        //     回递 下标 >= 32 ?
        //         位测试后位复位(T[1], 下标 - 32) :
        //         位测试后位复位(T[0], 下标);
        // }
        // 内联链接 自然数 置位位个数(U64 值) {
        //     字化对象<U64, U32> T = 值;
        //     回递 置位位个数(T[0]) + 置位位个数(T[1]);
        // }
        // 内联链接 自然数 复位位个数(U64 值) {
        //     回递 置位位个数(~值);
        // }
        // 内联链接 自然数 低位零个数(U64 值) {
        //     字化对象<U64, U32> T = 值;
        //     回递 
        //         低位零个数(T[0]) & 0x20 ?
        //         低位零个数(T[0]) : 
        //         低位零个数(T[0]) + 低位零个数(T[1]);
        // }
        // 内联链接 自然数 高位零个数(U64 值) {
        //     字化对象<U64, U32> T = 值;
        //     回递 
        //         高位零个数(T[1]) & 0x20 ?
        //         高位零个数(T[1]) + 0x20 : 
        //         高位零个数(T[0]);
        // }
        // 内联链接 自然数 最低置位位索引(U64 值){
        //     字化对象<U64, U32> T = 值;
        //     unsigned long R;

        //     若 (_BitScanForward(& R, T[0])){
        //         若 (_BitScanForward(& R, T[1])) {
        //             回递 不存在;
        //         }
        //         回递 自然数(R) + 32;
        //     }
        //     回递 自然数(R);
        // }
        // 内联链接 自然数 最高置位位索引(U64 值){
        // 字化对象<U64, U32> T = 值;
        // unsigned long R;

        // 若 (_BitScanForward(& R, T[1])){
        //     若 (_BitScanForward(& R, T[0])) {
        //         回递 不存在;
        //     }
        //     回递 自然数(R);
        // }
        // 回递 自然数(R) + 32;
    #endif

    #define 生成(类型)                                              \
    内联链接 布尔 位测试(类型 值, 自然数 下标) {                    \
        回递 (值 & (类型(1) << 下标)) != 0;                         \
    }                                                               \
    内联链接 布尔 位测试后位取反(类型 * 值, 自然数 下标) {          \
        类型  掩码 = (类型(1) << 下标);                             \
        布尔 结果 = (值[0] & 掩码) != 0;                            \
        值[0] ^= 掩码;                                              \
        回递 结果;                                                  \
    }                                                               \
    内联链接 布尔 位测试后位置位(类型 * 值, 自然数 下标) {          \
        类型  掩码 = (类型(1) << 下标);                             \
        布尔 结果 = (值[0] & 掩码) != 0;                            \
        值[0] |= 掩码;                                              \
        回递 结果;                                                  \
    }                                                               \
    内联链接 布尔 位测试后位复位(类型 * 值, 自然数 下标) {          \
        类型  掩码 = (类型(1) << 下标);                             \
        布尔 结果 = (值[0] & 掩码) != 0;                            \
        值[0] &= ~掩码;                                             \
        回递 结果;                                                  \
    }

    生成(U64);
    生成(U32);
    生成(U16);
    生成(U08);
    #undef 生成

    #define 生成(w,f)                           \
    内联链接 自然数 置位位个数(U ## w 值) {     \
        回递 (自然数)_popcnt ## w(值);          \
    }                                           \
    内联链接 自然数 复位位个数(U ## w 值) {     \
        回递 (自然数)__tzcnt_u ## w(值);        \
    }                                           \
    内联链接 自然数 最低置位位索引(U ## w 值){  \
        若 (值 == 0){                           \
            回递 不存在;                        \
        }                                       \
        回递 (自然数)__bsf ## f(值);            \
    }                                           \
    内联链接 自然数 最高置位位索引(U ## w 值){  \
        若 (值 == 0){                           \
            回递 不存在;                        \
        }                                       \
        回递 (自然数)__bsr ## f(值);            \
    }

    生成(32, d);

    #ifdef 六十四位系统
        生成(64, q);
    #endif
    #undef 生成

    #define 生成(x,w)                                   \
    内联链接 自然数 低位零个数(U ## w 值) {             \
        回递 _tzcnt_u ## w(值);                         \
    }                                                   \
    内联链接 自然数 高位零个数(U ## w 值) {             \
        回递 比特数(值) - 1 - 最高置位位索引((x)值);    \
    }                                                   \
    内联链接 自然数 低位一个数(U ## w 值) {             \
        回递 低位零个数((U ## w)~值);                   \
    }                                                   \
    内联链接 自然数 高位一个数(U ## w 值) {             \
        回递 高位零个数((U ## w)~值);                   \
    }

    生成(U32, 16);
    生成(U32, 32);

    #ifdef 六十四位系统
        生成(U64, 64);
    #endif
    #undef 生成

    #define 生成(w,f)                                       \
    内联链接 U ## w 循环左移(U ## w 被移数, 自然数 移数) {  \
        回递 (U ## w)__ror ## f(被移数, 移数);              \
    }                                                       \
    内联链接 U ## w 循环右移(U ## w 被移数, 自然数 移数) {  \
        回递 (U ## w)__rol ## f(被移数, 移数);              \
    }

    生成(08, b);
    生成(16, w);
    生成(32, d);

    #ifdef 六十四位系统
        生成(64, q);
    #endif
    #undef 生成

    内联链接 U64 时间戳() {
        回递 __rdtsc();
    }
}


命名空间 指令集 {
    #define 原子操作(类型)                                                  \
    内联链接 空 原子自增一(类型 & 甲) {                                     \
        引用空间 std;                                                       \
        atomic<类型> & 临时 = *(atomic<类型> *)(&甲);                       \
        临时++;                                                             \
    }                                                                       \
    内联链接 空 原子自减一(类型 & 甲) {                                     \
        引用空间 std;                                                       \
        atomic<类型> & 临时 = *(atomic<类型> *)(&甲);                       \
        临时--;                                                             \
    }                                                                       \
    内联链接 空 原子加法(类型 & 甲, 类型 乙) {                              \
        引用空间 std;                                                       \
        atomic<类型> & 临时 = *(atomic<类型> *)(&甲);                       \
        临时 += 乙;                                                         \
    }                                                                       \
    内联链接 空 原子减法(类型 & 甲, 类型 乙) {                              \
        引用空间 std;                                                       \
        atomic<类型> & 临时 = *(atomic<类型> *)(&甲);                       \
        临时 -= 乙;                                                         \
    }                                                                       \
    内联链接 类型 原子交换(类型 & 甲, 类型 & 乙) {                          \
        引用空间 std;                                                       \
        atomic<类型> & 临时 = *(atomic<类型> *)(&甲);                       \
        回递(临时.exchange(乙));                                            \
    }                                                                       \
    内联链接 类型 原子与(类型 & 甲, 类型 乙) {                              \
        引用空间 std;                                                       \
        atomic<类型> & 临时 = *(atomic<类型> *)(&甲);                       \
        回递(临时 &= 乙);                                                   \
    }                                                                       \
    内联链接 类型 原子或(类型 & 甲, 类型 乙) {                              \
        引用空间 std;                                                       \
        atomic<类型> & 临时 = *(atomic<类型> *)(&甲);                       \
        回递(临时 |= 乙);                                                   \
    }                                                                       \
    内联链接 类型 原子异或(类型 & 甲, 类型 乙) {                            \
        引用空间 std;                                                       \
        atomic<类型> & 临时 = *(atomic<类型> *)(&甲);                       \
        回递(临时 ^= 乙);                                                   \
    }                                                                       

    原子操作(U08);
    原子操作(U16);
    原子操作(U32);
    原子操作(U64);

    原子操作(I08);
    原子操作(I16);
    原子操作(I32);
    原子操作(I64);
    #undef 原子操作
}