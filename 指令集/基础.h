#pragma once
#include"基本定义/迷你.h"

命名空间 指令集{
    U64 加法(U64 & 低64位, U64 甲, U64 乙);
    U64 加法(U64 & 低64位, U64 甲, U64 乙, U64 进位);
    U64 减法(U64 & 低64位, U64 甲, U64 乙);
    U64 减法(U64 & 低64位, U64 甲, U64 乙, U64 借位);
    U64 乘法(U64 & 低64位, U64 甲, U64 乙);
    U64 除法(U64 & 低64位, U64 甲, U64 乙);
    I64 乘法(I64 & 低64位, I64 甲, I64 乙);
    I64 除法(I64 & 低64位, I64 甲, I64 乙);
    布尔 位测试(U64 值, 自然数 下标);
    布尔 位测试后位取反(U64 & 值, 自然数 下标);
    布尔 位测试后位置位(U64 & 值, 自然数 下标);
    布尔 位测试后位复位(U64 & 值, 自然数 下标);
    自然数 置位位个数(U64 值);
    自然数 复位位个数(U64 值);
    自然数 低位零个数(U64 值);
    自然数 低位一个数(U64 值);
    自然数 高位一个数(U64 值);
    自然数 高位零个数(U64 值);
    自然数 最低置位位索引(U64 值);
    自然数 最高置位位索引(U64 值);
    自然数 最低复位位索引(U64 值);
    自然数 最高复位位索引(U64 值);

    布尔 位测试(U32 值, 自然数 下标);
    布尔 位测试(U16 值, 自然数 下标);
    布尔 位测试(U08 值, 自然数 下标);
    布尔 位测试后位置位(U32 & 值, 自然数 下标);
    布尔 位测试后位置位(U16 & 值, 自然数 下标);
    布尔 位测试后位复位(U32 & 值, 自然数 下标);
    布尔 位测试后位复位(U16 & 值, 自然数 下标);
    布尔 位测试后位置位(U08 & 值, 自然数 下标);
    布尔 位测试后位复位(U08 & 值, 自然数 下标);
    布尔 位测试后位取反(U16 & 值, 自然数 下标);
    布尔 位测试后位取反(U32 & 值, 自然数 下标);
    布尔 位测试后位取反(U08 & 值, 自然数 下标);
    自然数 置位位个数(U32 值);
    自然数 置位位个数(U16 值);
    自然数 置位位个数(U08 值);
    自然数 复位位个数(U32 值);
    自然数 复位位个数(U16 值);
    自然数 复位位个数(U08 值);
    自然数 低位零个数(U32 值);
    自然数 低位零个数(U16 值);
    自然数 低位零个数(U08 值);
    自然数 高位零个数(U32 值);
    自然数 高位零个数(U16 值);
    自然数 高位零个数(U08 值);

    自然数 最低置位位索引(U32 值);
    自然数 最低置位位索引(U16 值);
    自然数 最低置位位索引(U08 值);
    自然数 最高置位位索引(U32 值);
    自然数 最高置位位索引(U16 值);
    自然数 最高置位位索引(U08 值);
    自然数 最低复位位索引(U32 值);
    自然数 最低复位位索引(U16 值);
    自然数 最低复位位索引(U08 值);
    自然数 最高复位位索引(U32 值);
    自然数 最高复位位索引(U16 值);
    自然数 最高复位位索引(U08 值);

    U08 循环左移(U08 被移数, 自然数 移数);
    U16 循环左移(U16 被移数, 自然数 移数);
    U32 循环左移(U32 被移数, 自然数 移数);
    U64 循环左移(U64 被移数, 自然数 移数);
    U08 循环右移(U08 被移数, 自然数 移数);
    U16 循环右移(U16 被移数, 自然数 移数);
    U32 循环右移(U32 被移数, 自然数 移数);
    U64 循环右移(U64 被移数, 自然数 移数);

    U64 时间戳();

    #define 原子操作(类型)                                                                                 \
    空 原子自增一(类型 & 甲) ;                                                                             \
    空 原子自减一(类型 & 甲) ;                                                                             \
    空 原子加法(类型 & 甲, 类型 乙) ;                                                                      \
    空 原子减法(类型 & 甲, 类型 乙);                                                                       \
    类型 原子与(类型 & 甲, 类型 乙) ;                                                                      \
    类型 原子或(类型 & 甲, 类型 乙);                                                                       \
    类型 原子异或(类型 & 甲, 类型 乙);                                                                     \
    类型 原子交换(类型 & 甲, 类型 & 乙);                                                                   \
    内联链接 类型 原子交换(类型 & 甲, 类型 && 乙) { 回递(原子交换(甲, (类型 &)乙)); }                      \
    内联链接 空 原子自增一(非寄 类型 & 甲) { 原子自增一((类型 &)甲); }                                     \
    内联链接 空 原子自减一(非寄 类型 & 甲) { 原子自减一((类型 &)甲); }                                     \
    内联链接 空 原子加法(非寄 类型 & 甲, 类型 乙) { 原子加法((类型 &)甲, 乙); }                            \
    内联链接 空 原子减法(非寄 类型 & 甲, 类型 乙) { 原子减法((类型 &)甲, 乙); }                            \
    内联链接 类型 原子与(非寄 类型 & 甲, 类型 乙) { 回递(原子与((类型 &)甲, 乙)); }                        \
    内联链接 类型 原子或(非寄 类型 & 甲, 类型 乙){ 回递(原子或((类型 &)甲, 乙)); }                         \
    内联链接 类型 原子异或(非寄 类型 & 甲, 类型 乙){ 回递(原子异或((类型 &)甲, 乙)); }                     \
    内联链接 类型 原子交换(非寄 类型 & 甲, 类型 & 乙) { 回递(原子交换((类型 &)甲, 乙)); }                  \
    内联链接 类型 原子交换(非寄 类型 & 甲, 类型 && 乙) { 回递(原子交换((类型 &)甲, 乙)); }

    原子操作(U08);
    原子操作(U16);
    原子操作(U32);
    原子操作(U64);

    原子操作(I08);
    原子操作(I16);
    原子操作(I32);
    原子操作(I64);
    #undef 原子操作
}